#Generated by ArithmeticExpressionCompiler ( https://flatassembler.github.io/compiler.html ) run in NodeJS.
#AsmStart ;Neka GNU Assembler obavijesti linkera da je "hybrid_sort" naziv potprograma...
#Inline assembly begins.
.global hybrid_sort
hybrid_sort:
#AsmEnd
#Inline assembly ended.
#If gornja_granica-donja_granica<2 ;Ako je niz duljine manje od 2 (0 ili 1), znaci da je vec poredan, pa prekidamo izvodenje ovog potprograma.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Pushing "(< (- gornja_granica donja_granica) 2)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel468131
fld1
jmp endOfTheLessThanComparisonLabel860626
secondOperandOfTheComparisonIsSmallerOrEqualLabel468131:
fldz
endOfTheLessThanComparisonLabel860626:
#Comparing the just-calculated expression with 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel31648
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart ;Kako radimo izvan sekcija, mozemo jednostavno prekinuti izvodenje potprograma asemblerskom naredbom "ret" (inace bismo, da radimo u sekcijama, morali znati vrti li se program na 32-bitnom ili 64-bitnom Linuxu).
#Inline assembly begins.
ret
#AsmEnd 
#Inline assembly ended.
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
ElseLabel31648:
EndIfLabel116699:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost := 0
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "0" to the FPU stack...
mov dword ptr [rip + result],0x0 #IEEE754 hex of 0
fld dword ptr [rip + result]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + razvrstanost],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i            := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i < gornja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel667528:
#Evaluating the expression after the "While" keyword
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "(< (- gornja_granica 1) i)" to the FPU stack...
fxch
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel433284
fld1
jmp endOfTheLessThanComparisonLabel12287
secondOperandOfTheComparisonIsSmallerOrEqualLabel433284:
fldz
endOfTheLessThanComparisonLabel12287:
#Comparing the expression to 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel60122
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost := razvrstanost + (originalni_niz[i] < originalni_niz[i + 1])
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Pushing "(originalni_niz (+ i 1))" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "(originalni_niz i)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "(< (originalni_niz (+ i 1)) (originalni_niz i))" to the FPU stack...
fxch
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel742243
fld1
jmp endOfTheLessThanComparisonLabel155228
secondOperandOfTheComparisonIsSmallerOrEqualLabel742243:
fldz
endOfTheLessThanComparisonLabel155228:
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [rip + razvrstanost]
#Pushing "(+ (< (originalni_niz (+ i 1)) (originalni_niz i)) razvrstanost)" to the FPU stack...
fxch
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + razvrstanost],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i            := i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel667528
EndWhileLabel60122:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost := razvrstanost / ( (gornja_granica - donja_granica - 1) / 2) - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- (- gornja_granica donja_granica) 1)" to the FPU stack...
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Pushing "(/ (- (- gornja_granica donja_granica) 1) 2)" to the FPU stack...
fdivp
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [rip + razvrstanost]
#Pushing "(/ (/ (- (- gornja_granica donja_granica) 1) 2) razvrstanost)" to the FPU stack...
fxch
fdivp
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- (/ (/ (- (- gornja_granica donja_granica) 1) 2) razvrstanost) 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + razvrstanost],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i            := 2
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<7 | i=7 
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel624557:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "7" to the FPU stack...
mov dword ptr [rip + result],0x40e00000 #IEEE754 hex of 7
fld dword ptr [rip + result]
#Pushing "(< i 7)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel211724
fld1
jmp endOfTheLessThanComparisonLabel505278
secondOperandOfTheComparisonIsSmallerOrEqualLabel211724:
fldz
endOfTheLessThanComparisonLabel505278:
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "7" to the FPU stack...
mov dword ptr [rip + result],0x40e00000 #IEEE754 hex of 7
fld dword ptr [rip + result]
#Pushing "(= i 7)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel276509
fld1
jmp endOfTheEqualityOperatorLabel822037
operandsOfTheEqualityOperatorAreNotEqualLabel276509:
fldz
endOfTheEqualityOperatorLabel822037:
#Pushing "(| (< i 7) (= i 7))" to the FPU stack...
fistp dword ptr [rip + result]
mov eax,dword ptr [rip + result]
fistp dword ptr [rip + result]
or dword ptr [rip + result],eax
fild dword ptr [rip + result]
#Comparing the expression to 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel26246
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost_na_potenciju[i] := pow(abs(razvrstanost), i) ;"pow(x,y)" je u AEC-u samo sintaksni secer za "exp(ln(x)*y)", i to vraca NaN za x=0 ili x<0. Nema ocitog nacina da se "pow(x,y)" prevede na asemblerski.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [rip + razvrstanost]
#Pushing "(abs razvrstanost)" to the FPU stack...
fabs
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "(pow (abs razvrstanost) i)" to the FPU stack...
fxch
fld1
fxch
fyl2x
fldl2e
fdivp
fmulp
fldl2e
fmulp
fld1
fscale
fxch
fld1
fxch
fprem
f2xm1
faddp
fmulp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + razvrstanost_na_potenciju]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost_na_potenciju[i] := (razvrstanost=0) ? 0 : (mod(i,2)=1 & razvrstanost<0) ? (-razvrstanost_na_potenciju[i]) : razvrstanost_na_potenciju[i] ;C-ov i JavaScriptin uvjetni operator nekad zna znatno skratiti kod, zato sam ga ugradio i u svoj jezik.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "(razvrstanost_na_potenciju i)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + razvrstanost_na_potenciju]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "(razvrstanost_na_potenciju i)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + razvrstanost_na_potenciju]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "0" to the FPU stack...
mov dword ptr [rip + result],0x0 #IEEE754 hex of 0
fld dword ptr [rip + result]
#Pushing "(- (razvrstanost_na_potenciju i) 0)" to the FPU stack...
fxch
fsubp
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Pushing "(mod i 2)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [rip + result]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(= (mod i 2) 1)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel204300
fld1
jmp endOfTheEqualityOperatorLabel639663
operandsOfTheEqualityOperatorAreNotEqualLabel204300:
fldz
endOfTheEqualityOperatorLabel639663:
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [rip + razvrstanost]
#Pushing "0" to the FPU stack...
mov dword ptr [rip + result],0x0 #IEEE754 hex of 0
fld dword ptr [rip + result]
#Pushing "(< razvrstanost 0)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel30973
fld1
jmp endOfTheLessThanComparisonLabel934606
secondOperandOfTheComparisonIsSmallerOrEqualLabel30973:
fldz
endOfTheLessThanComparisonLabel934606:
#Pushing "(& (= (mod i 2) 1) (< razvrstanost 0))" to the FPU stack...
fistp dword ptr [rip + result]
mov eax,dword ptr [rip + result]
fistp dword ptr [rip + result]
and dword ptr [rip + result],eax
fild dword ptr [rip + result]
#Pushing "(?: (& (= (mod i 2) 1) (< razvrstanost 0)) (- (razvrstanost_na_potenciju i) 0) (razvrstanost_na_potenciju i))" to the FPU stack...
fistp dword ptr [rip + result]
xor eax,eax
cmp dword ptr [rip + result],eax
jz firstOperandOfTheTernaryOperatorIsZeroLabel240601
fstp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
fstp dword ptr [rip + result]
mov dword ptr [rip + result],eax
fld dword ptr [rip + result]
jmp endOfTheTernaryOperatorLabel903796
firstOperandOfTheTernaryOperatorIsZeroLabel240601:
fstp dword ptr [rip + result]
endOfTheTernaryOperatorLabel903796:
#Pushing "0" to the FPU stack...
mov dword ptr [rip + result],0x0 #IEEE754 hex of 0
fld dword ptr [rip + result]
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [rip + razvrstanost]
#Pushing "0" to the FPU stack...
mov dword ptr [rip + result],0x0 #IEEE754 hex of 0
fld dword ptr [rip + result]
#Pushing "(= razvrstanost 0)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel812922
fld1
jmp endOfTheEqualityOperatorLabel507018
operandsOfTheEqualityOperatorAreNotEqualLabel812922:
fldz
endOfTheEqualityOperatorLabel507018:
#Pushing "(?: (= razvrstanost 0) 0 (?: (& (= (mod i 2) 1) (< razvrstanost 0)) (- (razvrstanost_na_potenciju i) 0) (razvrstanost_na_potenciju i)))" to the FPU stack...
fistp dword ptr [rip + result]
xor eax,eax
cmp dword ptr [rip + result],eax
jz firstOperandOfTheTernaryOperatorIsZeroLabel655608
fstp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
fstp dword ptr [rip + result]
mov dword ptr [rip + result],eax
fld dword ptr [rip + result]
jmp endOfTheTernaryOperatorLabel108489
firstOperandOfTheTernaryOperatorIsZeroLabel655608:
fstp dword ptr [rip + result]
endOfTheTernaryOperatorLabel108489:
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + razvrstanost_na_potenciju]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=i+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel624557
EndWhileLabel26246:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;Formula koju je ispisao genetski algoritam za predvidanje koliko ce usporedbi QuickSort napraviti: https://github.com/FlatAssembler/ArithmeticExpressionCompiler/tree/master/QuickSort/Genetic_algorithm_for_deriving_the_formula
#The entire line is a comment, moving on...
#polinom_pod_apsolutnom := 2.38854*razvrstanost_na_potenciju[7] - 0.284258*razvrstanost_na_potenciju[6] - 1.87104*razvrstanost_na_potenciju[5] + 0.372637*razvrstanost_na_potenciju[4] + 0.167242*razvrstanost_na_potenciju[3] - 0.0884977*razvrstanost_na_potenciju[2] + 0.315119*razvrstanost
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "7" to the FPU stack...
mov dword ptr [rip + result],0x40e00000 #IEEE754 hex of 7
fld dword ptr [rip + result]
#Pushing "(razvrstanost_na_potenciju 7)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + razvrstanost_na_potenciju]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "2.38854" to the FPU stack...
mov dword ptr [rip + result],0x4018ddd7 #IEEE754 hex of 2.38854
fld dword ptr [rip + result]
#Pushing "(* (razvrstanost_na_potenciju 7) 2.38854)" to the FPU stack...
fxch
fmulp
#Pushing "6" to the FPU stack...
mov dword ptr [rip + result],0x40c00000 #IEEE754 hex of 6
fld dword ptr [rip + result]
#Pushing "(razvrstanost_na_potenciju 6)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + razvrstanost_na_potenciju]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "0.284258" to the FPU stack...
mov dword ptr [rip + result],0x3e918a44 #IEEE754 hex of 0.284258
fld dword ptr [rip + result]
#Pushing "(* (razvrstanost_na_potenciju 6) 0.284258)" to the FPU stack...
fxch
fmulp
#Pushing "(- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258))" to the FPU stack...
fsubp
#Pushing "5" to the FPU stack...
mov dword ptr [rip + result],0x40a00000 #IEEE754 hex of 5
fld dword ptr [rip + result]
#Pushing "(razvrstanost_na_potenciju 5)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + razvrstanost_na_potenciju]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "1.87104" to the FPU stack...
mov dword ptr [rip + result],0x3fef7e3d #IEEE754 hex of 1.87104
fld dword ptr [rip + result]
#Pushing "(* (razvrstanost_na_potenciju 5) 1.87104)" to the FPU stack...
fxch
fmulp
#Pushing "(- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104))" to the FPU stack...
fsubp
#Pushing "4" to the FPU stack...
mov dword ptr [rip + result],0x40800000 #IEEE754 hex of 4
fld dword ptr [rip + result]
#Pushing "(razvrstanost_na_potenciju 4)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + razvrstanost_na_potenciju]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "0.372637" to the FPU stack...
mov dword ptr [rip + result],0x3ebeca47 #IEEE754 hex of 0.372637
fld dword ptr [rip + result]
#Pushing "(* (razvrstanost_na_potenciju 4) 0.372637)" to the FPU stack...
fxch
fmulp
#Pushing "(+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637))" to the FPU stack...
faddp
#Pushing "3" to the FPU stack...
mov dword ptr [rip + result],0x40400000 #IEEE754 hex of 3
fld dword ptr [rip + result]
#Pushing "(razvrstanost_na_potenciju 3)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + razvrstanost_na_potenciju]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "0.167242" to the FPU stack...
mov dword ptr [rip + result],0x3e2b417d #IEEE754 hex of 0.167242
fld dword ptr [rip + result]
#Pushing "(* (razvrstanost_na_potenciju 3) 0.167242)" to the FPU stack...
fxch
fmulp
#Pushing "(+ (+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637)) (* (razvrstanost_na_potenciju 3) 0.167242))" to the FPU stack...
faddp
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Pushing "(razvrstanost_na_potenciju 2)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + razvrstanost_na_potenciju]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "0.0884977" to the FPU stack...
mov dword ptr [rip + result],0x3db53e48 #IEEE754 hex of 0.0884977
fld dword ptr [rip + result]
#Pushing "(* (razvrstanost_na_potenciju 2) 0.0884977)" to the FPU stack...
fxch
fmulp
#Pushing "(- (+ (+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637)) (* (razvrstanost_na_potenciju 3) 0.167242)) (* (razvrstanost_na_potenciju 2) 0.0884977))" to the FPU stack...
fsubp
#Pushing "0.315119" to the FPU stack...
mov dword ptr [rip + result],0x3ea15747 #IEEE754 hex of 0.315119
fld dword ptr [rip + result]
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [rip + razvrstanost]
#Pushing "(* 0.315119 razvrstanost)" to the FPU stack...
fmulp
#Pushing "(+ (- (+ (+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637)) (* (razvrstanost_na_potenciju 3) 0.167242)) (* (razvrstanost_na_potenciju 2) 0.0884977)) (* 0.315119 razvrstanost))" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + polinom_pod_apsolutnom],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#Eulerov_broj_na_koju_potenciju := (ln(gornja_granica - donja_granica) + ln(ln(gornja_granica - donja_granica))) * 1.05 + (ln(gornja_granica - donja_granica) - ln(ln(gornja_granica - donja_granica)) - ln(2)) * 0.9163 * abs(polinom_pod_apsolutnom)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(ln (ln (- gornja_granica donja_granica)))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica)))" to the FPU stack...
fxch
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Pushing "(ln 2)" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2))" to the FPU stack...
fsubp
#Pushing "0.9163" to the FPU stack...
mov dword ptr [rip + result],0x3f6a92a3 #IEEE754 hex of 0.9163
fld dword ptr [rip + result]
#Pushing "(* (- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2)) 0.9163)" to the FPU stack...
fmulp
#Pushing "polinom_pod_apsolutnom" to the FPU stack...
fld dword ptr [rip + polinom_pod_apsolutnom]
#Pushing "(abs polinom_pod_apsolutnom)" to the FPU stack...
fabs
#Pushing "(* (* (- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2)) 0.9163) (abs polinom_pod_apsolutnom))" to the FPU stack...
fmulp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(ln (ln (- gornja_granica donja_granica)))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(+ (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica)))" to the FPU stack...
fxch
faddp
#Pushing "1.05" to the FPU stack...
mov dword ptr [rip + result],0x3f866666 #IEEE754 hex of 1.05
fld dword ptr [rip + result]
#Pushing "(* (+ (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) 1.05)" to the FPU stack...
fmulp
#Pushing "(+ (* (* (- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2)) 0.9163) (abs polinom_pod_apsolutnom)) (* (+ (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) 1.05))" to the FPU stack...
fxch
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + Eulerov_broj_na_koju_potenciju],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#koliko_usporedbi_ocekujemo_od_QuickSorta := exp(Eulerov_broj_na_koju_potenciju)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "Eulerov_broj_na_koju_potenciju" to the FPU stack...
fld dword ptr [rip + Eulerov_broj_na_koju_potenciju]
#Pushing "(exp Eulerov_broj_na_koju_potenciju)" to the FPU stack...
fldl2e
fmulp
fld1
fscale
fxch
fld1
fxch
fprem
f2xm1
faddp
fmulp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + koliko_usporedbi_ocekujemo_od_QuickSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#koliko_usporedbi_ocekujemo_od_MergeSorta := 2 * (gornja_granica - donja_granica) * ln(gornja_granica - donja_granica) / ln(2)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Pushing "(* (- gornja_granica donja_granica) 2)" to the FPU stack...
fxch
fmulp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(* (* (- gornja_granica donja_granica) 2) (ln (- gornja_granica donja_granica)))" to the FPU stack...
fmulp
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Pushing "(ln 2)" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(/ (* (* (- gornja_granica donja_granica) 2) (ln (- gornja_granica donja_granica))) (ln 2))" to the FPU stack...
fdivp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + koliko_usporedbi_ocekujemo_od_MergeSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If razvrstanost=1 ;Ako je niz vec poredan.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [rip + razvrstanost]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(= razvrstanost 1)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel976696
fld1
jmp endOfTheEqualityOperatorLabel785197
operandsOfTheEqualityOperatorAreNotEqualLabel976696:
fldz
endOfTheEqualityOperatorLabel785197:
#Comparing the just-calculated expression with 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel169718
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_vec_poredanih_podniza := broj_vec_poredanih_podniza + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_vec_poredanih_podniza" to the FPU stack...
fld dword ptr [rip + broj_vec_poredanih_podniza]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ broj_vec_poredanih_podniza 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + broj_vec_poredanih_podniza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#ElseIf razvrstanost = -1 ;Ako je niz obrnuto poredan...
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: ElseIf-statement.
#If the expression in the If-statement evaluates to 1...
jmp EndIfLabel921757
#If it evaluates to 0...
ElseLabel169718:
#Evaluating the expression after the ElseIf keyword...
#Pushing "0" to the FPU stack...
mov dword ptr [rip + result],0x0 #IEEE754 hex of 0
fld dword ptr [rip + result]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- 0 1)" to the FPU stack...
fsubp
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [rip + razvrstanost]
#Pushing "(= (- 0 1) razvrstanost)" to the FPU stack...
fxch
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel788411
fld1
jmp endOfTheEqualityOperatorLabel113141
operandsOfTheEqualityOperatorAreNotEqualLabel788411:
fldz
endOfTheEqualityOperatorLabel113141:
#Comparing that expression to 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether it was 0...
jz ElseLabel989865
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_obrnuto_poredanih_podniza := broj_obrnuto_poredanih_podniza + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_obrnuto_poredanih_podniza" to the FPU stack...
fld dword ptr [rip + broj_obrnuto_poredanih_podniza]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ broj_obrnuto_poredanih_podniza 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + broj_obrnuto_poredanih_podniza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i                              :=                      donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j                              :=                 gornja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel168174:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel173960
fld1
jmp endOfTheLessThanComparisonLabel648398
secondOperandOfTheComparisonIsSmallerOrEqualLabel173960:
fldz
endOfTheLessThanComparisonLabel648398:
#Comparing the expression to 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel549491
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i] := originalni_niz[j]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [rip + j]
#Pushing "(originalni_niz j)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + pomocni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j              :=             j - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [rip + j]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- j 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i              :=             i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel168174
EndWhileLabel549491:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i < gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel644289:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel15905
fld1
jmp endOfTheLessThanComparisonLabel301416
secondOperandOfTheComparisonIsSmallerOrEqualLabel15905:
fldz
endOfTheLessThanComparisonLabel301416:
#Comparing the expression to 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel218646
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i] := pomocni_niz[i]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "(pomocni_niz i)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + pomocni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel644289
EndWhileLabel218646:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#ElseIf koliko_usporedbi_ocekujemo_od_MergeSorta < koliko_usporedbi_ocekujemo_od_QuickSorta | vrh_stoga > pow(2, 10) - pow(2, 6) ;MergeSort algoritam (priblizno poredani podnizovi, za koje je MergeSort efikasniji od QuickSorta, a moj ga program takoder koristi kada ima jos malo mjesta na sistemskom stogu, pa QuickSort nije opcija)...
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: ElseIf-statement.
#If the expression in the If-statement evaluates to 1...
jmp EndIfLabel921757
#If it evaluates to 0...
ElseLabel989865:
#Evaluating the expression after the ElseIf keyword...
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Pushing "10" to the FPU stack...
mov dword ptr [rip + result],0x41200000 #IEEE754 hex of 10
fld dword ptr [rip + result]
#Pushing "(pow 2 10)" to the FPU stack...
fxch
fld1
fxch
fyl2x
fldl2e
fdivp
fmulp
fldl2e
fmulp
fld1
fscale
fxch
fld1
fxch
fprem
f2xm1
faddp
fmulp
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Pushing "6" to the FPU stack...
mov dword ptr [rip + result],0x40c00000 #IEEE754 hex of 6
fld dword ptr [rip + result]
#Pushing "(pow 2 6)" to the FPU stack...
fxch
fld1
fxch
fyl2x
fldl2e
fdivp
fmulp
fldl2e
fmulp
fld1
fscale
fxch
fld1
fxch
fprem
f2xm1
faddp
fmulp
#Pushing "(- (pow 2 10) (pow 2 6))" to the FPU stack...
fsubp
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "(> (- (pow 2 10) (pow 2 6)) vrh_stoga)" to the FPU stack...
fxch
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jnb secondOperandOfTheComparisonIsGreaterOrEqualLabel547360
fld1
jmp endOfTheGreaterThanComparisonLabel762819
secondOperandOfTheComparisonIsGreaterOrEqualLabel547360:
fldz
endOfTheGreaterThanComparisonLabel762819:
#Pushing "koliko_usporedbi_ocekujemo_od_MergeSorta" to the FPU stack...
fld dword ptr [rip + koliko_usporedbi_ocekujemo_od_MergeSorta]
#Pushing "koliko_usporedbi_ocekujemo_od_QuickSorta" to the FPU stack...
fld dword ptr [rip + koliko_usporedbi_ocekujemo_od_QuickSorta]
#Pushing "(< koliko_usporedbi_ocekujemo_od_MergeSorta koliko_usporedbi_ocekujemo_od_QuickSorta)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel72078
fld1
jmp endOfTheLessThanComparisonLabel484333
secondOperandOfTheComparisonIsSmallerOrEqualLabel72078:
fldz
endOfTheLessThanComparisonLabel484333:
#Pushing "(| (> (- (pow 2 10) (pow 2 6)) vrh_stoga) (< koliko_usporedbi_ocekujemo_od_MergeSorta koliko_usporedbi_ocekujemo_od_QuickSorta))" to the FPU stack...
fxch
fistp dword ptr [rip + result]
mov eax,dword ptr [rip + result]
fistp dword ptr [rip + result]
or dword ptr [rip + result],eax
fild dword ptr [rip + result]
#Comparing that expression to 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether it was 0...
jz ElseLabel942652
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_pokretanja_MergeSorta :=       broj_pokretanja_MergeSorta + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_pokretanja_MergeSorta" to the FPU stack...
fld dword ptr [rip + broj_pokretanja_MergeSorta]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ broj_pokretanja_MergeSorta 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + broj_pokretanja_MergeSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza               := (gornja_granica + donja_granica) / 2
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Pushing "(+ gornja_granica donja_granica)" to the FPU stack...
faddp
#Pushing "2" to the FPU stack...
mov dword ptr [rip + result],0x40000000 #IEEE754 hex of 2
fld dword ptr [rip + result]
#Pushing "(/ (+ gornja_granica donja_granica) 2)" to the FPU stack...
fdivp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza               :=   sredina_niza - mod(sredina_niza,1)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [rip + sredina_niza]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(mod sredina_niza 1)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [rip + result]
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [rip + sredina_niza]
#Pushing "(- (mod sredina_niza 1) sredina_niza)" to the FPU stack...
fxch
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga                  :=                        vrh_stoga + 1 ;Zauzmi mjesta na stogu za rekurziju. Ne koristimo sistemski stog, kao sto koristi C++, nego koristimo vise globalnih polja kao stogove. Da koristimo sistemski stog, morali bismo znati pokrecemo li se na 32-bitnom Linuxu ili 64-bitnom Linuxu, jer oni nisu kompatibilni u tom pogledu.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ vrh_stoga 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_donjim_granicama[vrh_stoga]  := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + stog_s_donjim_granicama]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_gornjim_granicama[vrh_stoga] := gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + stog_s_gornjim_granicama]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_sa_sredinama_niza[vrh_stoga]   := sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [rip + sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + stog_sa_sredinama_niza]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica                      := sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [rip + sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#donja_granica  :=  stog_s_donjim_granicama[vrh_stoga] ;Sad je rekurzija gotovo sigurno izmijenila sve globalne varijable koje nam trebaju ("donja_granica", "gornja_granica" i "sredina_niza"), ali zato imamo njihove stare vrijednosti na stogovima.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + stog_s_donjim_granicama]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica := stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + stog_s_gornjim_granicama]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza   :=   stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + stog_sa_sredinama_niza]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#donja_granica  :=                        sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [rip + sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#donja_granica  :=  stog_s_donjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + stog_s_donjim_granicama]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica := stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + stog_s_gornjim_granicama]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza   :=   stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + stog_sa_sredinama_niza]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;Spajanje nizova originalni_niz[donja_granica..sredina_niza] i originalni_niz[sredina_niza..gornja_granica] u jedan niz...
#The entire line is a comment, moving on...
#i                      := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_prvom_nizu  := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gdje_smo_u_prvom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_drugom_nizu := sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [rip + sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gdje_smo_u_drugom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel344849:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel943229
fld1
jmp endOfTheLessThanComparisonLabel33333
secondOperandOfTheComparisonIsSmallerOrEqualLabel943229:
fldz
endOfTheLessThanComparisonLabel33333:
#Comparing the expression to 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel147551
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If (gdje_smo_u_prvom_nizu=sredina_niza | originalni_niz[gdje_smo_u_drugom_nizu]<originalni_niz[gdje_smo_u_prvom_nizu]) & gdje_smo_u_drugom_nizu<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [rip + gdje_smo_u_drugom_nizu]
#Pushing "(originalni_niz gdje_smo_u_drugom_nizu)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [rip + gdje_smo_u_prvom_nizu]
#Pushing "(originalni_niz gdje_smo_u_prvom_nizu)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "(< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu))" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel652116
fld1
jmp endOfTheLessThanComparisonLabel354634
secondOperandOfTheComparisonIsSmallerOrEqualLabel652116:
fldz
endOfTheLessThanComparisonLabel354634:
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [rip + gdje_smo_u_prvom_nizu]
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [rip + sredina_niza]
#Pushing "(= gdje_smo_u_prvom_nizu sredina_niza)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel761424
fld1
jmp endOfTheEqualityOperatorLabel942053
operandsOfTheEqualityOperatorAreNotEqualLabel761424:
fldz
endOfTheEqualityOperatorLabel942053:
#Pushing "(| (< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu)) (= gdje_smo_u_prvom_nizu sredina_niza))" to the FPU stack...
fxch
fistp dword ptr [rip + result]
mov eax,dword ptr [rip + result]
fistp dword ptr [rip + result]
or dword ptr [rip + result],eax
fild dword ptr [rip + result]
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [rip + gdje_smo_u_drugom_nizu]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "(< gdje_smo_u_drugom_nizu gornja_granica)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel765321
fld1
jmp endOfTheLessThanComparisonLabel358718
secondOperandOfTheComparisonIsSmallerOrEqualLabel765321:
fldz
endOfTheLessThanComparisonLabel358718:
#Pushing "(& (| (< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu)) (= gdje_smo_u_prvom_nizu sredina_niza)) (< gdje_smo_u_drugom_nizu gornja_granica))" to the FPU stack...
fistp dword ptr [rip + result]
mov eax,dword ptr [rip + result]
fistp dword ptr [rip + result]
and dword ptr [rip + result],eax
fild dword ptr [rip + result]
#Comparing the just-calculated expression with 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel509791
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i]         := originalni_niz[gdje_smo_u_drugom_nizu]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [rip + gdje_smo_u_drugom_nizu]
#Pushing "(originalni_niz gdje_smo_u_drugom_nizu)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + pomocni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_drugom_nizu :=             gdje_smo_u_drugom_nizu + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [rip + gdje_smo_u_drugom_nizu]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ gdje_smo_u_drugom_nizu 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gdje_smo_u_drugom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#Else
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: Else-statement.
jmp EndIfLabel872436
ElseLabel509791:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i]        := originalni_niz[gdje_smo_u_prvom_nizu]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [rip + gdje_smo_u_prvom_nizu]
#Pushing "(originalni_niz gdje_smo_u_prvom_nizu)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + pomocni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_prvom_nizu := gdje_smo_u_prvom_nizu + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [rip + gdje_smo_u_prvom_nizu]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ gdje_smo_u_prvom_nizu 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gdje_smo_u_prvom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
EndIfLabel872436:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel344849
EndWhileLabel147551:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i < gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel704343:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel347113
fld1
jmp endOfTheLessThanComparisonLabel146438
secondOperandOfTheComparisonIsSmallerOrEqualLabel347113:
fldz
endOfTheLessThanComparisonLabel146438:
#Comparing the expression to 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel38524
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i] := pomocni_niz[i]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "(pomocni_niz i)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + pomocni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i                 :=          i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel704343
EndWhileLabel38524:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga:=vrh_stoga-1 ;Oslobodi mjesto na stogovima.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- vrh_stoga 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#Else ;QuickSort algoritam (nasumicno ispremjestani podnizovi)...
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: Else-statement.
jmp EndIfLabel921757
ElseLabel942652:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_pokretanja_QuickSorta := broj_pokretanja_QuickSorta + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_pokretanja_QuickSorta" to the FPU stack...
fld dword ptr [rip + broj_pokretanja_QuickSorta]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ broj_pokretanja_QuickSorta 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + broj_pokretanja_QuickSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;Daljnji kod je priblizno prepisan s https://www.geeksforgeeks.org/quick-sort/
#The entire line is a comment, moving on...
#pivot := originalni_niz[gornja_granica - 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "(originalni_niz (- gornja_granica 1))" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + pivot],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i     :=                  donja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- donja_granica 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j     :=                      donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While j < gornja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel375127:
#Evaluating the expression after the "While" keyword
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "j" to the FPU stack...
fld dword ptr [rip + j]
#Pushing "(< (- gornja_granica 1) j)" to the FPU stack...
fxch
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel278891
fld1
jmp endOfTheLessThanComparisonLabel87144
secondOperandOfTheComparisonIsSmallerOrEqualLabel278891:
fldz
endOfTheLessThanComparisonLabel87144:
#Comparing the expression to 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel238082
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If originalni_niz[j] < pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "j" to the FPU stack...
fld dword ptr [rip + j]
#Pushing "(originalni_niz j)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Pushing "pivot" to the FPU stack...
fld dword ptr [rip + pivot]
#Pushing "(< (originalni_niz j) pivot)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45
or ah,al
sahf
pop ax
fstp dword ptr [rip + result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel57343
fld1
jmp endOfTheLessThanComparisonLabel466224
secondOperandOfTheComparisonIsSmallerOrEqualLabel57343:
fldz
endOfTheLessThanComparisonLabel466224:
#Comparing the just-calculated expression with 0...
fistp dword ptr [rip + result]
mov eax, dword ptr [rip + result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel57596
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i                             :=                         i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocna_varijabla_za_zamijenu :=             originalni_niz[i]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "(originalni_niz i)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + pomocna_varijabla_za_zamijenu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i]             :=            originalni_niz [j]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [rip + j]
#Pushing "(originalni_niz j)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[j]             := pomocna_varijabla_za_zamijenu
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "pomocna_varijabla_za_zamijenu" to the FPU stack...
fld dword ptr [rip + pomocna_varijabla_za_zamijenu]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "j" to the FPU stack...
fld dword ptr [rip + j]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
ElseLabel57596:
EndIfLabel286592:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j := j + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [rip + j]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ j 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel375127
EndWhileLabel238082:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocna_varijabla_za_zamijenu       :=              originalni_niz[i + 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Pushing "(originalni_niz (+ i 1))" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + pomocna_varijabla_za_zamijenu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i + 1]               := originalni_niz[gornja_granica - 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "(originalni_niz (- gornja_granica 1))" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[gornja_granica - 1]  :=      pomocna_varijabla_za_zamijenu
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "pomocna_varijabla_za_zamijenu" to the FPU stack...
fld dword ptr [rip + pomocna_varijabla_za_zamijenu]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + originalni_niz]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_je_pivot                       :=                              i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [rip + i]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gdje_je_pivot],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga                           :=                      vrh_stoga + 1 ;Zauzmi mjesta na stogu za rekurziju (ne koristimo sistemski stog, kao sto koristi C++, nego koristimo vise globalnih polja kao stogove).
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(+ vrh_stoga 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_donjim_granicama[vrh_stoga]  :=                      donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [rip + donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + stog_s_donjim_granicama]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_gornjim_granicama[vrh_stoga] :=                     gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [rip + gornja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + stog_s_gornjim_granicama]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_sa_sredinama_niza[vrh_stoga]   :=                      gdje_je_pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_je_pivot" to the FPU stack...
fld dword ptr [rip + gdje_je_pivot]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx, dword ptr [rip + result]
#Storing the r-value (now in "edx") where "ebx" points to.
lea r9, dword ptr [rip + stog_sa_sredinama_niza]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
mov dword ptr [r9],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica                      :=                      gdje_je_pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_je_pivot" to the FPU stack...
fld dword ptr [rip + gdje_je_pivot]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#donja_granica  :=  stog_s_donjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + stog_s_donjim_granicama]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica := stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + stog_s_gornjim_granicama]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_je_pivot  :=   stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [rip + result]
xor rbx, rbx
mov ebx,dword ptr [rip + result]
lea r9, dword ptr [rip + stog_sa_sredinama_niza]
shl rbx, 2 #Multiply rbx by 4, the number of bytes in Float32
add r9, rbx
fld dword ptr [r9]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + gdje_je_pivot],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#donja_granica  :=                       gdje_je_pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_je_pivot" to the FPU stack...
fld dword ptr [rip + gdje_je_pivot]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#vrh_stoga := vrh_stoga - 1 ;Oslobodi mjesto na stogovima.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [rip + vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [rip + result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [rip + result]
#Pushing "(- vrh_stoga 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [rip + result]
mov edx, dword ptr [rip + result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [rip + vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
EndIfLabel921757:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart ;Ovdje tok programa ne smije doci. Ako dode, pozovi debugger.
#Inline assembly begins.
call abort
#AsmEnd
#Inline assembly ended.
#
#The entire line is a comment, moving on...
