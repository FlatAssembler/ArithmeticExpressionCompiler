#Generated by ArithmeticExpressionCompiler ( https://flatassembler.github.io/compiler.html ) run in NodeJS.
#AsmStart
#Inline assembly begins.
.global fibonacci #We need to tell the linker that "fibonacci" is the name of a function, and not some random label.
fibonacci:
#AsmEnd
#Inline assembly ended.
#If not(mod(n,1)=0) ;If 'n' is not a integer, round it to the nearest integer.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(mod n 1)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [result]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "(= (mod n 1) 0)" to the FPU stack...
fcomip
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel542993
fld1
jmp endOfTheEqualityOperatorLabel255508
operandsOfTheEqualityOperatorAreNotEqualLabel542993:
fldz
endOfTheEqualityOperatorLabel255508:
#Pushing "(not (= (mod n 1) 0))" to the FPU stack...
fld1
fxch
fsubp
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel168974
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#n := n + ( mod(n,1) > 1/2 ? 1-mod(n,1) : (-mod(n,1)))
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(mod n 1)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [result]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "(- (mod n 1) 0)" to the FPU stack...
fxch
fsubp
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(mod n 1)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [result]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- (mod n 1) 1)" to the FPU stack...
fxch
fsubp
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(mod n 1)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [result]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(/ 1 2)" to the FPU stack...
fdivp
#Pushing "(> (mod n 1) (/ 1 2))" to the FPU stack...
fcomip
fstp dword ptr [result]
jnb secondOperandOfTheComparisonIsGreaterOrEqualLabel346935
fld1
jmp endOfTheGreaterThanComparisonLabel689158
secondOperandOfTheComparisonIsGreaterOrEqualLabel346935:
fldz
endOfTheGreaterThanComparisonLabel689158:
#Pushing "(?: (> (mod n 1) (/ 1 2)) (- (mod n 1) 1) (- (mod n 1) 0))" to the FPU stack...
fistp dword ptr [result]
xor eax,eax
cmp dword ptr [result],eax
jz firstOperandOfTheTernaryOperatorIsZeroLabel465597
fstp dword ptr [result]
mov eax, dword ptr [result]
fstp dword ptr [result]
mov dword ptr [result],eax
fld dword ptr [result]
jmp endOfTheTernaryOperatorLabel397331
firstOperandOfTheTernaryOperatorIsZeroLabel465597:
fstp dword ptr [result]
endOfTheTernaryOperatorLabel397331:
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "(+ (?: (> (mod n 1) (/ 1 2)) (- (mod n 1) 1) (- (mod n 1) 0)) n)" to the FPU stack...
fxch
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [n],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
ElseLabel168974:
EndIfLabel783099:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If n<2 ;The 1st Fibonacci number is 1, and the 0th one is 0.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(< n 2)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel463128
fld1
jmp endOfTheLessThanComparisonLabel395168
secondOperandOfTheComparisonIsSmallerOrEqualLabel463128:
fldz
endOfTheLessThanComparisonLabel395168:
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel135545
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#returnValue := n > -1 ? n : 0/0 ;0/0 is NaN (indicating error), because negative Fibonacci numbers don't exist
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "(/ 0 0)" to the FPU stack...
fdivp
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- 0 1)" to the FPU stack...
fsubp
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "(> (- 0 1) n)" to the FPU stack...
fxch
fcomip
fstp dword ptr [result]
jnb secondOperandOfTheComparisonIsGreaterOrEqualLabel125235
fld1
jmp endOfTheGreaterThanComparisonLabel484298
secondOperandOfTheComparisonIsGreaterOrEqualLabel125235:
fldz
endOfTheGreaterThanComparisonLabel484298:
#Pushing "(?: (> (- 0 1) n) n (/ 0 0))" to the FPU stack...
fistp dword ptr [result]
xor eax,eax
cmp dword ptr [result],eax
jz firstOperandOfTheTernaryOperatorIsZeroLabel764898
fstp dword ptr [result]
mov eax, dword ptr [result]
fstp dword ptr [result]
mov dword ptr [result],eax
fld dword ptr [result]
jmp endOfTheTernaryOperatorLabel330441
firstOperandOfTheTernaryOperatorIsZeroLabel764898:
fstp dword ptr [result]
endOfTheTernaryOperatorLabel330441:
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [returnValue],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
.intel_syntax noprefix
ret #Far return (to the other section, that is, to the C++ program). The way to do a same-section return depends on whether we are in a 32-bit Assembler or a 64-bit Assembler, while the far return is the same (at least in the "intel_syntax mode").
.att_syntax
#AsmEnd
#Inline assembly ended.
#ElseIf not(memoisation[n]=0) ;Has that Fibonacci number already been calculated?
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: ElseIf-statement.
#If the expression in the If-statement evaluates to 1...
jmp EndIfLabel931727
#If it evaluates to 0...
ElseLabel135545:
#Evaluating the expression after the ElseIf keyword...
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "(memoisation n)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [memoisation+4*ebx]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "(= (memoisation n) 0)" to the FPU stack...
fcomip
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel477580
fld1
jmp endOfTheEqualityOperatorLabel199217
operandsOfTheEqualityOperatorAreNotEqualLabel477580:
fldz
endOfTheEqualityOperatorLabel199217:
#Pushing "(not (= (memoisation n) 0))" to the FPU stack...
fld1
fxch
fsubp
#Comparing that expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it was 0...
jz ElseLabel488049
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#returnValue:=memoisation[n]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "(memoisation n)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [memoisation+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [returnValue],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
.intel_syntax noprefix
ret
.att_syntax
#AsmEnd
#Inline assembly ended.
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
ElseLabel488049:
EndIfLabel931727:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;And now comes the part where we are tricking ArithmeticExpressionCompiler into supporting recursion...
#The entire line is a comment, moving on...
#topOfTheStackWithLocalVariables := topOfTheStackWithLocalVariables + 2 ;Allocate space on the stack for 2 local variables ('n', the argument passed to the function, and the temporary result).
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "topOfTheStackWithLocalVariables" to the FPU stack...
fld dword ptr [topOfTheStackWithLocalVariables]
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(+ topOfTheStackWithLocalVariables 2)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [topOfTheStackWithLocalVariables],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#temporaryResult := 0 ;The sum of fib(n-1) and fib(n-2) will be stored here, first 0 then fib(n-1) then fib(n-1)+fib(n-2).
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [temporaryResult],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stackWithLocalVariables[topOfTheStackWithLocalVariables - 1] := temporaryResult ;Save the local variables onto the stack, for the recursive calls will corrupt them (as they are actually global variables, because ArithmeticExpressionCompiler doesn't support local ones).
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "temporaryResult" to the FPU stack...
fld dword ptr [temporaryResult]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "topOfTheStackWithLocalVariables" to the FPU stack...
fld dword ptr [topOfTheStackWithLocalVariables]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- topOfTheStackWithLocalVariables 1)" to the FPU stack...
fsubp
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stackWithLocalVariables+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stackWithLocalVariables[topOfTheStackWithLocalVariables] := n
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "topOfTheStackWithLocalVariables" to the FPU stack...
fld dword ptr [topOfTheStackWithLocalVariables]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stackWithLocalVariables+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#n:=n-1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- n 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [n],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
.intel_syntax noprefix
call fibonacci
.att_syntax
#AsmEnd
#Inline assembly ended.
#temporaryResult := stackWithLocalVariables[topOfTheStackWithLocalVariables - 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "topOfTheStackWithLocalVariables" to the FPU stack...
fld dword ptr [topOfTheStackWithLocalVariables]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- topOfTheStackWithLocalVariables 1)" to the FPU stack...
fsubp
#Pushing "(stackWithLocalVariables (- topOfTheStackWithLocalVariables 1))" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stackWithLocalVariables+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [temporaryResult],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#temporaryResult := temporaryResult + returnValue ;"returnValue" is supposed to contain fib(n-1).
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "temporaryResult" to the FPU stack...
fld dword ptr [temporaryResult]
#Pushing "returnValue" to the FPU stack...
fld dword ptr [returnValue]
#Pushing "(+ temporaryResult returnValue)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [temporaryResult],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;And we repeat what we did the last time, now with n-2 instead of n-1...
#The entire line is a comment, moving on...
#stackWithLocalVariables[topOfTheStackWithLocalVariables - 1] := temporaryResult
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "temporaryResult" to the FPU stack...
fld dword ptr [temporaryResult]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "topOfTheStackWithLocalVariables" to the FPU stack...
fld dword ptr [topOfTheStackWithLocalVariables]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- topOfTheStackWithLocalVariables 1)" to the FPU stack...
fsubp
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stackWithLocalVariables+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#n := stackWithLocalVariables[topOfTheStackWithLocalVariables]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "topOfTheStackWithLocalVariables" to the FPU stack...
fld dword ptr [topOfTheStackWithLocalVariables]
#Pushing "(stackWithLocalVariables topOfTheStackWithLocalVariables)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stackWithLocalVariables+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [n],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#n := n - 2
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(- n 2)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [n],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
.intel_syntax noprefix
call fibonacci
.att_syntax
#AsmEnd
#Inline assembly ended.
#temporaryResult := stackWithLocalVariables[topOfTheStackWithLocalVariables - 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "topOfTheStackWithLocalVariables" to the FPU stack...
fld dword ptr [topOfTheStackWithLocalVariables]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- topOfTheStackWithLocalVariables 1)" to the FPU stack...
fsubp
#Pushing "(stackWithLocalVariables (- topOfTheStackWithLocalVariables 1))" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stackWithLocalVariables+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [temporaryResult],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#temporaryResult := temporaryResult + returnValue
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "temporaryResult" to the FPU stack...
fld dword ptr [temporaryResult]
#Pushing "returnValue" to the FPU stack...
fld dword ptr [returnValue]
#Pushing "(+ temporaryResult returnValue)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [temporaryResult],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stackWithLocalVariables[topOfTheStackWithLocalVariables - 1] := temporaryResult
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "temporaryResult" to the FPU stack...
fld dword ptr [temporaryResult]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "topOfTheStackWithLocalVariables" to the FPU stack...
fld dword ptr [topOfTheStackWithLocalVariables]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- topOfTheStackWithLocalVariables 1)" to the FPU stack...
fsubp
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stackWithLocalVariables+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#n := stackWithLocalVariables [topOfTheStackWithLocalVariables]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "topOfTheStackWithLocalVariables" to the FPU stack...
fld dword ptr [topOfTheStackWithLocalVariables]
#Pushing "(stackWithLocalVariables topOfTheStackWithLocalVariables)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stackWithLocalVariables+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [n],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#returnValue := temporaryResult
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "temporaryResult" to the FPU stack...
fld dword ptr [temporaryResult]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [returnValue],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#memoisation[n] := returnValue
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "returnValue" to the FPU stack...
fld dword ptr [returnValue]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "n" to the FPU stack...
fld dword ptr [n]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [memoisation+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#topOfTheStackWithLocalVariables := topOfTheStackWithLocalVariables - 2
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "topOfTheStackWithLocalVariables" to the FPU stack...
fld dword ptr [topOfTheStackWithLocalVariables]
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(- topOfTheStackWithLocalVariables 2)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [topOfTheStackWithLocalVariables],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
.intel_syntax noprefix
ret
.att_syntax
#AsmEnd
#Inline assembly ended.
#
#The entire line is a comment, moving on...
