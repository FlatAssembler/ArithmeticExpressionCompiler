#Generated by ArithmeticExpressionCompiler ( https://flatassembler.github.io/compiler.html ) run in NodeJS.
#AsmStart
#Inline assembly begins.
.global merge_sort
merge_sort:
#AsmEnd
#Inline assembly ended.
#If gornja_granica-donja_granica<2
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(< (- gornja_granica donja_granica) 2)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel912722
fld1
jmp endOfTheLessThanComparisonLabel982089
secondOperandOfTheComparisonIsSmallerOrEqualLabel912722:
fldz
endOfTheLessThanComparisonLabel982089:
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel375740
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd 
#Inline assembly ended.
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
ElseLabel375740:
EndIfLabel922550:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza:=(gornja_granica+donja_granica)/2
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(+ gornja_granica donja_granica)" to the FPU stack...
faddp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(/ (+ gornja_granica donja_granica) 2)" to the FPU stack...
fdivp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza:=sredina_niza-mod(sredina_niza,1)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(mod sredina_niza 1)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [result]
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Pushing "(- (mod sredina_niza 1) sredina_niza)" to the FPU stack...
fxch
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga:=vrh_stoga+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ vrh_stoga 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_donjim_granicama[vrh_stoga]:=donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_s_donjim_granicama+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_gornjim_granicama[vrh_stoga]:=gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_s_gornjim_granicama+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_sa_sredinama_niza[vrh_stoga]:=sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_sa_sredinama_niza+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica:=sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call merge_sort
#AsmEnd
#Inline assembly ended.
#donja_granica:=stog_s_donjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_donjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica:=stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_gornjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza:=stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_sa_sredinama_niza+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#donja_granica:=sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call merge_sort
#AsmEnd
#Inline assembly ended.
#donja_granica:=stog_s_donjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_donjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica:=stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_gornjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza:=stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_sa_sredinama_niza+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_prvom_nizu:=donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_prvom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_drugom_nizu:=sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_drugom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel712934:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel129478
fld1
jmp endOfTheLessThanComparisonLabel669555
secondOperandOfTheComparisonIsSmallerOrEqualLabel129478:
fldz
endOfTheLessThanComparisonLabel669555:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel693497
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If (gdje_smo_u_prvom_nizu=sredina_niza | originalni_niz[gdje_smo_u_drugom_nizu]<originalni_niz[gdje_smo_u_prvom_nizu]) & gdje_smo_u_drugom_nizu<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "(originalni_niz gdje_smo_u_drugom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "(originalni_niz gdje_smo_u_prvom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "(< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu))" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel999739
fld1
jmp endOfTheLessThanComparisonLabel553500
secondOperandOfTheComparisonIsSmallerOrEqualLabel999739:
fldz
endOfTheLessThanComparisonLabel553500:
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Pushing "(= gdje_smo_u_prvom_nizu sredina_niza)" to the FPU stack...
fcomip
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel413934
fld1
jmp endOfTheEqualityOperatorLabel185598
operandsOfTheEqualityOperatorAreNotEqualLabel413934:
fldz
endOfTheEqualityOperatorLabel185598:
#Pushing "(| (< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu)) (= gdje_smo_u_prvom_nizu sredina_niza))" to the FPU stack...
fxch
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
or dword ptr [result],eax
fild dword ptr [result]
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< gdje_smo_u_drugom_nizu gornja_granica)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel667554
fld1
jmp endOfTheLessThanComparisonLabel898678
secondOperandOfTheComparisonIsSmallerOrEqualLabel667554:
fldz
endOfTheLessThanComparisonLabel898678:
#Pushing "(& (| (< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu)) (= gdje_smo_u_prvom_nizu sredina_niza)) (< gdje_smo_u_drugom_nizu gornja_granica))" to the FPU stack...
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
and dword ptr [result],eax
fild dword ptr [result]
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel719035
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i]:=originalni_niz[gdje_smo_u_drugom_nizu]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "(originalni_niz gdje_smo_u_drugom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [pomocni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_drugom_nizu:=gdje_smo_u_drugom_nizu+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ gdje_smo_u_drugom_nizu 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_drugom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#Else
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: Else-statement.
jmp EndIfLabel134972
ElseLabel719035:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i]:=originalni_niz[gdje_smo_u_prvom_nizu]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "(originalni_niz gdje_smo_u_prvom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [pomocni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_prvom_nizu:=gdje_smo_u_prvom_nizu+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ gdje_smo_u_prvom_nizu 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_prvom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
EndIfLabel134972:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=i+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel712934
EndWhileLabel693497:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel3614:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel680006
fld1
jmp endOfTheLessThanComparisonLabel709823
secondOperandOfTheComparisonIsSmallerOrEqualLabel680006:
fldz
endOfTheLessThanComparisonLabel709823:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel766098
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i]:=pomocni_niz[i]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(pomocni_niz i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [pomocni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=i+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel3614
EndWhileLabel766098:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga:=vrh_stoga-1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- vrh_stoga 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#
#The entire line is a comment, moving on...
