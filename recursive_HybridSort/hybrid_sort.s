#Generated by ArithmeticExpressionCompiler ( https://flatassembler.github.io/compiler.html ) run in NodeJS.
#AsmStart ;Neka GNU Assembler obavijesti linkera da je "hybrid_sort" naziv potprograma...
#Inline assembly begins.
.global hybrid_sort
hybrid_sort:
#AsmEnd
#Inline assembly ended.
#If gornja_granica-donja_granica<2 ;Ako je niz duljine manje od 2 (0 ili 1), znaci da je vec poredan, pa prekidamo izvodenje ovog potprograma.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(< (- gornja_granica donja_granica) 2)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel914728
fld1
jmp endOfTheLessThanComparisonLabel862181
secondOperandOfTheComparisonIsSmallerOrEqualLabel914728:
fldz
endOfTheLessThanComparisonLabel862181:
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel529946
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart ;Kako radimo izvan sekcija, mozemo jednostavno prekinuti izvodenje potprograma asemblerskom naredbom "ret" (inace bismo, da radimo u sekcijama, morali znati vrti li se program na 32-bitnom ili 64-bitnom Linuxu).
#Inline assembly begins.
ret
#AsmEnd 
#Inline assembly ended.
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
ElseLabel529946:
EndIfLabel210662:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost:=0
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [razvrstanost],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i < gornja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel766296:
#Evaluating the expression after the "While" keyword
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(< (- gornja_granica 1) i)" to the FPU stack...
fxch
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel765653
fld1
jmp endOfTheLessThanComparisonLabel147775
secondOperandOfTheComparisonIsSmallerOrEqualLabel765653:
fldz
endOfTheLessThanComparisonLabel147775:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel280132
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost:=razvrstanost+(originalni_niz[i]<originalni_niz[i+1])
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Pushing "(originalni_niz (+ i 1))" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(originalni_niz i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "(< (originalni_niz (+ i 1)) (originalni_niz i))" to the FPU stack...
fxch
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel42606
fld1
jmp endOfTheLessThanComparisonLabel143093
secondOperandOfTheComparisonIsSmallerOrEqualLabel42606:
fldz
endOfTheLessThanComparisonLabel143093:
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "(+ (< (originalni_niz (+ i 1)) (originalni_niz i)) razvrstanost)" to the FPU stack...
fxch
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [razvrstanost],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=i+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel766296
EndWhileLabel280132:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost:=razvrstanost/((gornja_granica-donja_granica-1)/2)-1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- (- gornja_granica donja_granica) 1)" to the FPU stack...
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(/ (- (- gornja_granica donja_granica) 1) 2)" to the FPU stack...
fdivp
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "(/ (/ (- (- gornja_granica donja_granica) 1) 2) razvrstanost)" to the FPU stack...
fxch
fdivp
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- (/ (/ (- (- gornja_granica donja_granica) 1) 2) razvrstanost) 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [razvrstanost],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=2
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<7 | i=7 
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel373162:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "7" to the FPU stack...
mov dword ptr [result],0x40e00000 #IEEE754 hex of 7
fld dword ptr [result]
#Pushing "(< i 7)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel163363
fld1
jmp endOfTheLessThanComparisonLabel975466
secondOperandOfTheComparisonIsSmallerOrEqualLabel163363:
fldz
endOfTheLessThanComparisonLabel975466:
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "7" to the FPU stack...
mov dword ptr [result],0x40e00000 #IEEE754 hex of 7
fld dword ptr [result]
#Pushing "(= i 7)" to the FPU stack...
fcomip
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel509
fld1
jmp endOfTheEqualityOperatorLabel963015
operandsOfTheEqualityOperatorAreNotEqualLabel509:
fldz
endOfTheEqualityOperatorLabel963015:
#Pushing "(| (< i 7) (= i 7))" to the FPU stack...
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
or dword ptr [result],eax
fild dword ptr [result]
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel314523
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost_na_potenciju[i] := pow(abs(razvrstanost), i) ;"pow(x,y)" je u AEC-u samo sintaksni secer za "exp(ln(x)*y)", i to vraca NaN za x=0 ili x<0. Nema ocitog nacina da se "pow(x,y)" prevede na asemblerski.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "(abs razvrstanost)" to the FPU stack...
fabs
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(pow (abs razvrstanost) i)" to the FPU stack...
fxch
fld1
fxch
fyl2x
fldl2e
fdivp
fmulp
fldl2e
fmulp
fld1
fscale
fxch
fld1
fxch
fprem
f2xm1
faddp
fmulp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [razvrstanost_na_potenciju+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost_na_potenciju[i] := (razvrstanost=0) ? 0 : (mod(i,2)=1 & razvrstanost<0) ? (-razvrstanost_na_potenciju[i]) : razvrstanost_na_potenciju[i] ;C-ov i JavaScriptin uvjetni operator nekad zna znatno skratiti kod, zato sam ga ugradio i u svoj jezik.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(razvrstanost_na_potenciju i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(razvrstanost_na_potenciju i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "(- (razvrstanost_na_potenciju i) 0)" to the FPU stack...
fxch
fsubp
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(mod i 2)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [result]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(= (mod i 2) 1)" to the FPU stack...
fcomip
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel437097
fld1
jmp endOfTheEqualityOperatorLabel642028
operandsOfTheEqualityOperatorAreNotEqualLabel437097:
fldz
endOfTheEqualityOperatorLabel642028:
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "(< razvrstanost 0)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel182457
fld1
jmp endOfTheLessThanComparisonLabel685474
secondOperandOfTheComparisonIsSmallerOrEqualLabel182457:
fldz
endOfTheLessThanComparisonLabel685474:
#Pushing "(& (= (mod i 2) 1) (< razvrstanost 0))" to the FPU stack...
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
and dword ptr [result],eax
fild dword ptr [result]
#Pushing "(?: (& (= (mod i 2) 1) (< razvrstanost 0)) (- (razvrstanost_na_potenciju i) 0) (razvrstanost_na_potenciju i))" to the FPU stack...
fistp dword ptr [result]
xor eax,eax
cmp dword ptr [result],eax
jz firstOperandOfTheTernaryOperatorIsZeroLabel838153
fstp dword ptr [result]
mov eax, dword ptr [result]
fstp dword ptr [result]
mov dword ptr [result],eax
fld dword ptr [result]
jmp endOfTheTernaryOperatorLabel564969
firstOperandOfTheTernaryOperatorIsZeroLabel838153:
fstp dword ptr [result]
endOfTheTernaryOperatorLabel564969:
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "(= razvrstanost 0)" to the FPU stack...
fcomip
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel110939
fld1
jmp endOfTheEqualityOperatorLabel486506
operandsOfTheEqualityOperatorAreNotEqualLabel110939:
fldz
endOfTheEqualityOperatorLabel486506:
#Pushing "(?: (= razvrstanost 0) 0 (?: (& (= (mod i 2) 1) (< razvrstanost 0)) (- (razvrstanost_na_potenciju i) 0) (razvrstanost_na_potenciju i)))" to the FPU stack...
fistp dword ptr [result]
xor eax,eax
cmp dword ptr [result],eax
jz firstOperandOfTheTernaryOperatorIsZeroLabel718367
fstp dword ptr [result]
mov eax, dword ptr [result]
fstp dword ptr [result]
mov dword ptr [result],eax
fld dword ptr [result]
jmp endOfTheTernaryOperatorLabel749902
firstOperandOfTheTernaryOperatorIsZeroLabel718367:
fstp dword ptr [result]
endOfTheTernaryOperatorLabel749902:
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [razvrstanost_na_potenciju+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=i+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel373162
EndWhileLabel314523:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;Formula koju je ispisao genetski algoritam za predvidanje koliko ce usporedbi QuickSort napraviti: https://github.com/FlatAssembler/ArithmeticExpressionCompiler/tree/master/QuickSort/Genetic_algorithm_for_deriving_the_formula
#The entire line is a comment, moving on...
#polinom_pod_apsolutnom := 2.38854*razvrstanost_na_potenciju[7] - 0.284258*razvrstanost_na_potenciju[6] - 1.87104*razvrstanost_na_potenciju[5] + 0.372637*razvrstanost_na_potenciju[4] + 0.167242*razvrstanost_na_potenciju[3] - 0.0884977*razvrstanost_na_potenciju[2] + 0.315119*razvrstanost
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "7" to the FPU stack...
mov dword ptr [result],0x40e00000 #IEEE754 hex of 7
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 7)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "2.38854" to the FPU stack...
mov dword ptr [result],0x4018ddd7 #IEEE754 hex of 2.38854
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 7) 2.38854)" to the FPU stack...
fxch
fmulp
#Pushing "6" to the FPU stack...
mov dword ptr [result],0x40c00000 #IEEE754 hex of 6
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 6)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "0.284258" to the FPU stack...
mov dword ptr [result],0x3e918a44 #IEEE754 hex of 0.284258
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 6) 0.284258)" to the FPU stack...
fxch
fmulp
#Pushing "(- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258))" to the FPU stack...
fsubp
#Pushing "5" to the FPU stack...
mov dword ptr [result],0x40a00000 #IEEE754 hex of 5
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 5)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "1.87104" to the FPU stack...
mov dword ptr [result],0x3fef7e3d #IEEE754 hex of 1.87104
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 5) 1.87104)" to the FPU stack...
fxch
fmulp
#Pushing "(- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104))" to the FPU stack...
fsubp
#Pushing "4" to the FPU stack...
mov dword ptr [result],0x40800000 #IEEE754 hex of 4
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 4)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "0.372637" to the FPU stack...
mov dword ptr [result],0x3ebeca47 #IEEE754 hex of 0.372637
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 4) 0.372637)" to the FPU stack...
fxch
fmulp
#Pushing "(+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637))" to the FPU stack...
faddp
#Pushing "3" to the FPU stack...
mov dword ptr [result],0x40400000 #IEEE754 hex of 3
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 3)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "0.167242" to the FPU stack...
mov dword ptr [result],0x3e2b417d #IEEE754 hex of 0.167242
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 3) 0.167242)" to the FPU stack...
fxch
fmulp
#Pushing "(+ (+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637)) (* (razvrstanost_na_potenciju 3) 0.167242))" to the FPU stack...
faddp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 2)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "0.0884977" to the FPU stack...
mov dword ptr [result],0x3db53e48 #IEEE754 hex of 0.0884977
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 2) 0.0884977)" to the FPU stack...
fxch
fmulp
#Pushing "(- (+ (+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637)) (* (razvrstanost_na_potenciju 3) 0.167242)) (* (razvrstanost_na_potenciju 2) 0.0884977))" to the FPU stack...
fsubp
#Pushing "0.315119" to the FPU stack...
mov dword ptr [result],0x3ea15747 #IEEE754 hex of 0.315119
fld dword ptr [result]
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "(* 0.315119 razvrstanost)" to the FPU stack...
fmulp
#Pushing "(+ (- (+ (+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637)) (* (razvrstanost_na_potenciju 3) 0.167242)) (* (razvrstanost_na_potenciju 2) 0.0884977)) (* 0.315119 razvrstanost))" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [polinom_pod_apsolutnom],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#Eulerov_broj_na_koju_potenciju := (ln(gornja_granica - donja_granica) + ln(ln(gornja_granica - donja_granica))) * 1.05 + (ln(gornja_granica - donja_granica) - ln(ln(gornja_granica - donja_granica)) - ln(2)) * 0.9163 * abs(polinom_pod_apsolutnom)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(ln (ln (- gornja_granica donja_granica)))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica)))" to the FPU stack...
fxch
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(ln 2)" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2))" to the FPU stack...
fsubp
#Pushing "0.9163" to the FPU stack...
mov dword ptr [result],0x3f6a92a3 #IEEE754 hex of 0.9163
fld dword ptr [result]
#Pushing "(* (- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2)) 0.9163)" to the FPU stack...
fmulp
#Pushing "polinom_pod_apsolutnom" to the FPU stack...
fld dword ptr [polinom_pod_apsolutnom]
#Pushing "(abs polinom_pod_apsolutnom)" to the FPU stack...
fabs
#Pushing "(* (* (- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2)) 0.9163) (abs polinom_pod_apsolutnom))" to the FPU stack...
fmulp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(ln (ln (- gornja_granica donja_granica)))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(+ (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica)))" to the FPU stack...
fxch
faddp
#Pushing "1.05" to the FPU stack...
mov dword ptr [result],0x3f866666 #IEEE754 hex of 1.05
fld dword ptr [result]
#Pushing "(* (+ (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) 1.05)" to the FPU stack...
fmulp
#Pushing "(+ (* (* (- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2)) 0.9163) (abs polinom_pod_apsolutnom)) (* (+ (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) 1.05))" to the FPU stack...
fxch
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [Eulerov_broj_na_koju_potenciju],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#koliko_usporedbi_ocekujemo_od_QuickSorta := exp(Eulerov_broj_na_koju_potenciju)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "Eulerov_broj_na_koju_potenciju" to the FPU stack...
fld dword ptr [Eulerov_broj_na_koju_potenciju]
#Pushing "(exp Eulerov_broj_na_koju_potenciju)" to the FPU stack...
fldl2e
fmulp
fld1
fscale
fxch
fld1
fxch
fprem
f2xm1
faddp
fmulp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [koliko_usporedbi_ocekujemo_od_QuickSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#koliko_usporedbi_ocekujemo_od_MergeSorta := 2 * (gornja_granica - donja_granica) * ln(gornja_granica - donja_granica) / ln(2)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(* (- gornja_granica donja_granica) 2)" to the FPU stack...
fxch
fmulp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(* (* (- gornja_granica donja_granica) 2) (ln (- gornja_granica donja_granica)))" to the FPU stack...
fmulp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(ln 2)" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(/ (* (* (- gornja_granica donja_granica) 2) (ln (- gornja_granica donja_granica))) (ln 2))" to the FPU stack...
fdivp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [koliko_usporedbi_ocekujemo_od_MergeSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If razvrstanost=1 ;Ako je niz vec poredan.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(= razvrstanost 1)" to the FPU stack...
fcomip
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel679583
fld1
jmp endOfTheEqualityOperatorLabel948175
operandsOfTheEqualityOperatorAreNotEqualLabel679583:
fldz
endOfTheEqualityOperatorLabel948175:
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel693997
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_vec_poredanih_podniza := broj_vec_poredanih_podniza + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_vec_poredanih_podniza" to the FPU stack...
fld dword ptr [broj_vec_poredanih_podniza]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ broj_vec_poredanih_podniza 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [broj_vec_poredanih_podniza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#ElseIf razvrstanost = -1 ;Ako je niz obrnuto poredan...
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: ElseIf-statement.
#If the expression in the If-statement evaluates to 1...
jmp EndIfLabel234383
#If it evaluates to 0...
ElseLabel693997:
#Evaluating the expression after the ElseIf keyword...
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- 0 1)" to the FPU stack...
fsubp
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "(= (- 0 1) razvrstanost)" to the FPU stack...
fxch
fcomip
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel588601
fld1
jmp endOfTheEqualityOperatorLabel394986
operandsOfTheEqualityOperatorAreNotEqualLabel588601:
fldz
endOfTheEqualityOperatorLabel394986:
#Comparing that expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it was 0...
jz ElseLabel987446
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_obrnuto_poredanih_podniza := broj_obrnuto_poredanih_podniza + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_obrnuto_poredanih_podniza" to the FPU stack...
fld dword ptr [broj_obrnuto_poredanih_podniza]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ broj_obrnuto_poredanih_podniza 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [broj_obrnuto_poredanih_podniza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j:=gornja_granica-1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel265037:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel736657
fld1
jmp endOfTheLessThanComparisonLabel410196
secondOperandOfTheComparisonIsSmallerOrEqualLabel736657:
fldz
endOfTheLessThanComparisonLabel410196:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel151273
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i] := originalni_niz[j]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "(originalni_niz j)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [pomocni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j := j - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- j 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel265037
EndWhileLabel151273:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i < gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel513913:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel435970
fld1
jmp endOfTheLessThanComparisonLabel419677
secondOperandOfTheComparisonIsSmallerOrEqualLabel435970:
fldz
endOfTheLessThanComparisonLabel419677:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel509398
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i] := pomocni_niz[i]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(pomocni_niz i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [pomocni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel513913
EndWhileLabel509398:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#ElseIf koliko_usporedbi_ocekujemo_od_MergeSorta < koliko_usporedbi_ocekujemo_od_QuickSorta ;MergeSort algoritam (priblizno poredani podnizovi, za koje je MergeSort efikasniji od QuickSorta)...
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: ElseIf-statement.
#If the expression in the If-statement evaluates to 1...
jmp EndIfLabel234383
#If it evaluates to 0...
ElseLabel987446:
#Evaluating the expression after the ElseIf keyword...
#Pushing "koliko_usporedbi_ocekujemo_od_MergeSorta" to the FPU stack...
fld dword ptr [koliko_usporedbi_ocekujemo_od_MergeSorta]
#Pushing "koliko_usporedbi_ocekujemo_od_QuickSorta" to the FPU stack...
fld dword ptr [koliko_usporedbi_ocekujemo_od_QuickSorta]
#Pushing "(< koliko_usporedbi_ocekujemo_od_MergeSorta koliko_usporedbi_ocekujemo_od_QuickSorta)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel711177
fld1
jmp endOfTheLessThanComparisonLabel803100
secondOperandOfTheComparisonIsSmallerOrEqualLabel711177:
fldz
endOfTheLessThanComparisonLabel803100:
#Comparing that expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it was 0...
jz ElseLabel158195
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_pokretanja_MergeSorta := broj_pokretanja_MergeSorta + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_pokretanja_MergeSorta" to the FPU stack...
fld dword ptr [broj_pokretanja_MergeSorta]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ broj_pokretanja_MergeSorta 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [broj_pokretanja_MergeSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza:=(gornja_granica+donja_granica)/2
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(+ gornja_granica donja_granica)" to the FPU stack...
faddp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(/ (+ gornja_granica donja_granica) 2)" to the FPU stack...
fdivp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza:=sredina_niza-mod(sredina_niza,1)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(mod sredina_niza 1)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [result]
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Pushing "(- (mod sredina_niza 1) sredina_niza)" to the FPU stack...
fxch
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga:=vrh_stoga+1 ;Zauzmi mjesta na stogu za rekurziju. Ne koristimo sistemski stog, kao sto koristi C++, nego koristimo vise globalnih polja kao stogove. Da koristimo sistemski stog, morali bismo znati pokrecemo li se na 32-bitnom Linuxu ili 64-bitnom Linuxu, jer oni nisu kompatibilni u tom pogledu.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ vrh_stoga 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_donjim_granicama[vrh_stoga]:=donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_s_donjim_granicama+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_gornjim_granicama[vrh_stoga]:=gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_s_gornjim_granicama+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_sa_sredinama_niza[vrh_stoga]:=sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_sa_sredinama_niza+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica:=sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#donja_granica:=stog_s_donjim_granicama[vrh_stoga] ;Sad je rekurzija gotovo sigurno izmijenila sve globalne varijable koje nam trebaju ("donja_granica", "gornja_granica" i "sredina_niza"), ali zato imamo njihove stare vrijednosti na stogovima.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_donjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica:=stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_gornjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza:=stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_sa_sredinama_niza+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#donja_granica:=sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#donja_granica:=stog_s_donjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_donjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica:=stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_gornjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza:=stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_sa_sredinama_niza+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;Spajanje nizova originalni_niz[donja_granica..sredina_niza] i originalni_niz[sredina_niza..gornja_granica] u jedan niz...
#The entire line is a comment, moving on...
#i:=donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_prvom_nizu:=donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_prvom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_drugom_nizu:=sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_drugom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel473114:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel561654
fld1
jmp endOfTheLessThanComparisonLabel512603
secondOperandOfTheComparisonIsSmallerOrEqualLabel561654:
fldz
endOfTheLessThanComparisonLabel512603:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel931174
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If (gdje_smo_u_prvom_nizu=sredina_niza | originalni_niz[gdje_smo_u_drugom_nizu]<originalni_niz[gdje_smo_u_prvom_nizu]) & gdje_smo_u_drugom_nizu<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "(originalni_niz gdje_smo_u_drugom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "(originalni_niz gdje_smo_u_prvom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "(< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu))" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel863228
fld1
jmp endOfTheLessThanComparisonLabel971626
secondOperandOfTheComparisonIsSmallerOrEqualLabel863228:
fldz
endOfTheLessThanComparisonLabel971626:
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Pushing "(= gdje_smo_u_prvom_nizu sredina_niza)" to the FPU stack...
fcomip
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel518097
fld1
jmp endOfTheEqualityOperatorLabel710435
operandsOfTheEqualityOperatorAreNotEqualLabel518097:
fldz
endOfTheEqualityOperatorLabel710435:
#Pushing "(| (< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu)) (= gdje_smo_u_prvom_nizu sredina_niza))" to the FPU stack...
fxch
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
or dword ptr [result],eax
fild dword ptr [result]
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< gdje_smo_u_drugom_nizu gornja_granica)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel999050
fld1
jmp endOfTheLessThanComparisonLabel994778
secondOperandOfTheComparisonIsSmallerOrEqualLabel999050:
fldz
endOfTheLessThanComparisonLabel994778:
#Pushing "(& (| (< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu)) (= gdje_smo_u_prvom_nizu sredina_niza)) (< gdje_smo_u_drugom_nizu gornja_granica))" to the FPU stack...
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
and dword ptr [result],eax
fild dword ptr [result]
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel740225
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i]:=originalni_niz[gdje_smo_u_drugom_nizu]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "(originalni_niz gdje_smo_u_drugom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [pomocni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_drugom_nizu:=gdje_smo_u_drugom_nizu+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ gdje_smo_u_drugom_nizu 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_drugom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#Else
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: Else-statement.
jmp EndIfLabel616433
ElseLabel740225:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i]:=originalni_niz[gdje_smo_u_prvom_nizu]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "(originalni_niz gdje_smo_u_prvom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [pomocni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_prvom_nizu:=gdje_smo_u_prvom_nizu+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ gdje_smo_u_prvom_nizu 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_prvom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
EndIfLabel616433:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=i+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel473114
EndWhileLabel931174:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel384782:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel244623
fld1
jmp endOfTheLessThanComparisonLabel112767
secondOperandOfTheComparisonIsSmallerOrEqualLabel244623:
fldz
endOfTheLessThanComparisonLabel112767:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel529747
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i]:=pomocni_niz[i]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(pomocni_niz i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [pomocni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=i+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel384782
EndWhileLabel529747:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga:=vrh_stoga-1 ;Oslobodi mjesto na stogovima.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- vrh_stoga 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#Else ;QuickSort algoritam (nasumicno ispremjestani podnizovi)...
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: Else-statement.
jmp EndIfLabel234383
ElseLabel158195:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_pokretanja_QuickSorta := broj_pokretanja_QuickSorta + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_pokretanja_QuickSorta" to the FPU stack...
fld dword ptr [broj_pokretanja_QuickSorta]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ broj_pokretanja_QuickSorta 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [broj_pokretanja_QuickSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;Daljnji kod je priblizno prepisan s https://www.geeksforgeeks.org/quick-sort/
#The entire line is a comment, moving on...
#pivot := originalni_niz[gornja_granica - 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "(originalni_niz (- gornja_granica 1))" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [pivot],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := donja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- donja_granica 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While j < gornja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel990848:
#Evaluating the expression after the "While" keyword
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "(< (- gornja_granica 1) j)" to the FPU stack...
fxch
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel675272
fld1
jmp endOfTheLessThanComparisonLabel746036
secondOperandOfTheComparisonIsSmallerOrEqualLabel675272:
fldz
endOfTheLessThanComparisonLabel746036:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel611367
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If originalni_niz[j] < pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "(originalni_niz j)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "pivot" to the FPU stack...
fld dword ptr [pivot]
#Pushing "(< (originalni_niz j) pivot)" to the FPU stack...
fcomip
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel657472
fld1
jmp endOfTheLessThanComparisonLabel130696
secondOperandOfTheComparisonIsSmallerOrEqualLabel657472:
fldz
endOfTheLessThanComparisonLabel130696:
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel637071
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocna_varijabla_za_zamijenu := originalni_niz[i]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(originalni_niz i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [pomocna_varijabla_za_zamijenu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i] := originalni_niz [j]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "(originalni_niz j)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[j] := pomocna_varijabla_za_zamijenu
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "pomocna_varijabla_za_zamijenu" to the FPU stack...
fld dword ptr [pomocna_varijabla_za_zamijenu]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
ElseLabel637071:
EndIfLabel14996:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j:=j+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ j 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel990848
EndWhileLabel611367:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocna_varijabla_za_zamijenu := originalni_niz[i + 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Pushing "(originalni_niz (+ i 1))" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [pomocna_varijabla_za_zamijenu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i + 1] := originalni_niz[gornja_granica - 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "(originalni_niz (- gornja_granica 1))" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[gornja_granica - 1] := pomocna_varijabla_za_zamijenu
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "pomocna_varijabla_za_zamijenu" to the FPU stack...
fld dword ptr [pomocna_varijabla_za_zamijenu]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_je_pivot := i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_je_pivot],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga := vrh_stoga + 1 ;Zauzmi mjesta na stogu za rekurziju (ne koristimo sistemski stog, kao sto koristi C++, nego koristimo vise globalnih polja kao stogove).
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ vrh_stoga 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_donjim_granicama[vrh_stoga] := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_s_donjim_granicama+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_gornjim_granicama[vrh_stoga] := gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_s_gornjim_granicama+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_sa_sredinama_niza[vrh_stoga] := gdje_je_pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_je_pivot" to the FPU stack...
fld dword ptr [gdje_je_pivot]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_sa_sredinama_niza+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica := gdje_je_pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_je_pivot" to the FPU stack...
fld dword ptr [gdje_je_pivot]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#donja_granica := stog_s_donjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_donjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica := stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_gornjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_je_pivot := stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_sa_sredinama_niza+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_je_pivot],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#donja_granica := gdje_je_pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_je_pivot" to the FPU stack...
fld dword ptr [gdje_je_pivot]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#vrh_stoga := vrh_stoga - 1 ;Oslobodi mjesto na stogovima.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- vrh_stoga 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
EndIfLabel234383:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart ;Ovdje tok programa ne smije doci. Ako dode, pozovi debugger.
#Inline assembly begins.
call abort
#AsmEnd
#Inline assembly ended.
#
#The entire line is a comment, moving on...
