#Generated by Arithmetic Expression Compiler (https://flatassembler.github.io/compiler.html) run in Duktape.
#AsmStart ;Neka GNU Assembler obavijesti linkera da je "hybrid_sort" naziv potprograma...
#Inline assembly begins.
.global hybrid_sort
hybrid_sort:
#AsmEnd
#Inline assembly ended.
#If gornja_granica-donja_granica<2 ;Ako je niz duljine manje od 2 (0 ili 1), znaci da je vec poredan, pa prekidamo izvodenje ovog potprograma.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(< (- gornja_granica donja_granica) 2)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel623950
fld1
jmp endOfTheLessThanComparisonLabel819911
secondOperandOfTheComparisonIsSmallerOrEqualLabel623950:
fldz
endOfTheLessThanComparisonLabel819911:
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel51943
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart ;Kako radimo izvan sekcija, mozemo jednostavno prekinuti izvodenje potprograma asemblerskom naredbom "ret" (inace bismo, da radimo u sekcijama, morali znati vrti li se program na 32-bitnom ili 64-bitnom Linuxu).
#Inline assembly begins.
ret
#AsmEnd 
#Inline assembly ended.
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
ElseLabel51943:
EndIfLabel874051:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost := 0
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [razvrstanost],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i            := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i < gornja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel792159:
#Evaluating the expression after the "While" keyword
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(< (- gornja_granica 1) i)" to the FPU stack...
fxch
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel650918
fld1
jmp endOfTheLessThanComparisonLabel437502
secondOperandOfTheComparisonIsSmallerOrEqualLabel650918:
fldz
endOfTheLessThanComparisonLabel437502:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel466935
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost := razvrstanost + (originalni_niz[i] < originalni_niz[i + 1])
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Pushing "(originalni_niz (+ i 1))" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(originalni_niz i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "(< (originalni_niz (+ i 1)) (originalni_niz i))" to the FPU stack...
fxch
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel922794
fld1
jmp endOfTheLessThanComparisonLabel95110
secondOperandOfTheComparisonIsSmallerOrEqualLabel922794:
fldz
endOfTheLessThanComparisonLabel95110:
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "(+ (< (originalni_niz (+ i 1)) (originalni_niz i)) razvrstanost)" to the FPU stack...
fxch
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [razvrstanost],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i            := i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel792159
EndWhileLabel466935:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost := razvrstanost / ( (gornja_granica - donja_granica - 1) / 2) - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- (- gornja_granica donja_granica) 1)" to the FPU stack...
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(/ (- (- gornja_granica donja_granica) 1) 2)" to the FPU stack...
fdivp
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "(/ (/ (- (- gornja_granica donja_granica) 1) 2) razvrstanost)" to the FPU stack...
fxch
fdivp
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- (/ (/ (- (- gornja_granica donja_granica) 1) 2) razvrstanost) 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [razvrstanost],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i            := 2
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<7 | i=7 
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel664596:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "7" to the FPU stack...
mov dword ptr [result],0x40e00000 #IEEE754 hex of 7
fld dword ptr [result]
#Pushing "(< i 7)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel145675
fld1
jmp endOfTheLessThanComparisonLabel338711
secondOperandOfTheComparisonIsSmallerOrEqualLabel145675:
fldz
endOfTheLessThanComparisonLabel338711:
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "7" to the FPU stack...
mov dword ptr [result],0x40e00000 #IEEE754 hex of 7
fld dword ptr [result]
#Pushing "(= i 7)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel389518
fld1
jmp endOfTheEqualityOperatorLabel70061
operandsOfTheEqualityOperatorAreNotEqualLabel389518:
fldz
endOfTheEqualityOperatorLabel70061:
#Pushing "(| (< i 7) (= i 7))" to the FPU stack...
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
or dword ptr [result],eax
fild dword ptr [result]
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel538021
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost_na_potenciju[i] := pow(abs(razvrstanost), i) ;"pow(x,y)" je u AEC-u samo sintaksni secer za "exp(ln(x)*y)", i to vraca NaN za x=0 ili x<0. Nema ocitog nacina da se "pow(x,y)" prevede na asemblerski.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "(abs razvrstanost)" to the FPU stack...
fabs
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(pow (abs razvrstanost) i)" to the FPU stack...
fxch
fld1
fxch
fyl2x
fldl2e
fdivp
fmulp
fldl2e
fmulp
fld1
fscale
fxch
fld1
fxch
fprem
f2xm1
faddp
fmulp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [razvrstanost_na_potenciju+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#razvrstanost_na_potenciju[i] := (razvrstanost=0) ? 0 : (mod(i,2)=1 & razvrstanost<0) ? (-razvrstanost_na_potenciju[i]) : razvrstanost_na_potenciju[i] ;C-ov i JavaScriptin uvjetni operator nekad zna znatno skratiti kod, zato sam ga ugradio i u svoj jezik.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(razvrstanost_na_potenciju i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(razvrstanost_na_potenciju i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "(- (razvrstanost_na_potenciju i) 0)" to the FPU stack...
fxch
fsubp
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(mod i 2)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [result]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(= (mod i 2) 1)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel875892
fld1
jmp endOfTheEqualityOperatorLabel206688
operandsOfTheEqualityOperatorAreNotEqualLabel875892:
fldz
endOfTheEqualityOperatorLabel206688:
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "(< razvrstanost 0)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel118005
fld1
jmp endOfTheLessThanComparisonLabel662122
secondOperandOfTheComparisonIsSmallerOrEqualLabel118005:
fldz
endOfTheLessThanComparisonLabel662122:
#Pushing "(& (= (mod i 2) 1) (< razvrstanost 0))" to the FPU stack...
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
and dword ptr [result],eax
fild dword ptr [result]
#Pushing "(?: (& (= (mod i 2) 1) (< razvrstanost 0)) (- (razvrstanost_na_potenciju i) 0) (razvrstanost_na_potenciju i))" to the FPU stack...
fistp dword ptr [result]
xor eax,eax
cmp dword ptr [result],eax
jz firstOperandOfTheTernaryOperatorIsZeroLabel305729
fstp dword ptr [result]
mov eax, dword ptr [result]
fstp dword ptr [result]
mov dword ptr [result],eax
fld dword ptr [result]
jmp endOfTheTernaryOperatorLabel451126
firstOperandOfTheTernaryOperatorIsZeroLabel305729:
fstp dword ptr [result]
endOfTheTernaryOperatorLabel451126:
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "(= razvrstanost 0)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel971190
fld1
jmp endOfTheEqualityOperatorLabel735725
operandsOfTheEqualityOperatorAreNotEqualLabel971190:
fldz
endOfTheEqualityOperatorLabel735725:
#Pushing "(?: (= razvrstanost 0) 0 (?: (& (= (mod i 2) 1) (< razvrstanost 0)) (- (razvrstanost_na_potenciju i) 0) (razvrstanost_na_potenciju i)))" to the FPU stack...
fistp dword ptr [result]
xor eax,eax
cmp dword ptr [result],eax
jz firstOperandOfTheTernaryOperatorIsZeroLabel618751
fstp dword ptr [result]
mov eax, dword ptr [result]
fstp dword ptr [result]
mov dword ptr [result],eax
fld dword ptr [result]
jmp endOfTheTernaryOperatorLabel904935
firstOperandOfTheTernaryOperatorIsZeroLabel618751:
fstp dword ptr [result]
endOfTheTernaryOperatorLabel904935:
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [razvrstanost_na_potenciju+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i:=i+1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel664596
EndWhileLabel538021:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;Formula koju je ispisao genetski algoritam za predvidanje koliko ce usporedbi QuickSort napraviti: https://github.com/FlatAssembler/ArithmeticExpressionCompiler/tree/master/QuickSort/Genetic_algorithm_for_deriving_the_formula
#The entire line is a comment, moving on...
#polinom_pod_apsolutnom := 2.38854*razvrstanost_na_potenciju[7] - 0.284258*razvrstanost_na_potenciju[6] - 1.87104*razvrstanost_na_potenciju[5] + 0.372637*razvrstanost_na_potenciju[4] + 0.167242*razvrstanost_na_potenciju[3] - 0.0884977*razvrstanost_na_potenciju[2] + 0.315119*razvrstanost
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "7" to the FPU stack...
mov dword ptr [result],0x40e00000 #IEEE754 hex of 7
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 7)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "2.38854" to the FPU stack...
mov dword ptr [result],0x4018ddd7 #IEEE754 hex of 2.38854
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 7) 2.38854)" to the FPU stack...
fxch
fmulp
#Pushing "6" to the FPU stack...
mov dword ptr [result],0x40c00000 #IEEE754 hex of 6
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 6)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "0.284258" to the FPU stack...
mov dword ptr [result],0x3e918a44 #IEEE754 hex of 0.284258
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 6) 0.284258)" to the FPU stack...
fxch
fmulp
#Pushing "(- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258))" to the FPU stack...
fsubp
#Pushing "5" to the FPU stack...
mov dword ptr [result],0x40a00000 #IEEE754 hex of 5
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 5)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "1.87104" to the FPU stack...
mov dword ptr [result],0x3fef7e3d #IEEE754 hex of 1.87104
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 5) 1.87104)" to the FPU stack...
fxch
fmulp
#Pushing "(- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104))" to the FPU stack...
fsubp
#Pushing "4" to the FPU stack...
mov dword ptr [result],0x40800000 #IEEE754 hex of 4
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 4)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "0.372637" to the FPU stack...
mov dword ptr [result],0x3ebeca47 #IEEE754 hex of 0.372637
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 4) 0.372637)" to the FPU stack...
fxch
fmulp
#Pushing "(+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637))" to the FPU stack...
faddp
#Pushing "3" to the FPU stack...
mov dword ptr [result],0x40400000 #IEEE754 hex of 3
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 3)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "0.167242" to the FPU stack...
mov dword ptr [result],0x3e2b417d #IEEE754 hex of 0.167242
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 3) 0.167242)" to the FPU stack...
fxch
fmulp
#Pushing "(+ (+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637)) (* (razvrstanost_na_potenciju 3) 0.167242))" to the FPU stack...
faddp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(razvrstanost_na_potenciju 2)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [razvrstanost_na_potenciju+4*ebx]
#Pushing "0.0884977" to the FPU stack...
mov dword ptr [result],0x3db53e48 #IEEE754 hex of 0.0884977
fld dword ptr [result]
#Pushing "(* (razvrstanost_na_potenciju 2) 0.0884977)" to the FPU stack...
fxch
fmulp
#Pushing "(- (+ (+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637)) (* (razvrstanost_na_potenciju 3) 0.167242)) (* (razvrstanost_na_potenciju 2) 0.0884977))" to the FPU stack...
fsubp
#Pushing "0.315119" to the FPU stack...
mov dword ptr [result],0x3ea15747 #IEEE754 hex of 0.315119
fld dword ptr [result]
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "(* 0.315119 razvrstanost)" to the FPU stack...
fmulp
#Pushing "(+ (- (+ (+ (- (- (* (razvrstanost_na_potenciju 7) 2.38854) (* (razvrstanost_na_potenciju 6) 0.284258)) (* (razvrstanost_na_potenciju 5) 1.87104)) (* (razvrstanost_na_potenciju 4) 0.372637)) (* (razvrstanost_na_potenciju 3) 0.167242)) (* (razvrstanost_na_potenciju 2) 0.0884977)) (* 0.315119 razvrstanost))" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [polinom_pod_apsolutnom],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#Eulerov_broj_na_koju_potenciju := (ln(gornja_granica - donja_granica) + ln(ln(gornja_granica - donja_granica))) * 1.05 + (ln(gornja_granica - donja_granica) - ln(ln(gornja_granica - donja_granica)) - ln(2)) * 0.9163 * abs(polinom_pod_apsolutnom)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(ln (ln (- gornja_granica donja_granica)))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica)))" to the FPU stack...
fxch
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(ln 2)" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2))" to the FPU stack...
fsubp
#Pushing "0.9163" to the FPU stack...
mov dword ptr [result],0x3f6a92a3 #IEEE754 hex of 0.9163
fld dword ptr [result]
#Pushing "(* (- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2)) 0.9163)" to the FPU stack...
fmulp
#Pushing "polinom_pod_apsolutnom" to the FPU stack...
fld dword ptr [polinom_pod_apsolutnom]
#Pushing "(abs polinom_pod_apsolutnom)" to the FPU stack...
fabs
#Pushing "(* (* (- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2)) 0.9163) (abs polinom_pod_apsolutnom))" to the FPU stack...
fmulp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(ln (ln (- gornja_granica donja_granica)))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(+ (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica)))" to the FPU stack...
fxch
faddp
#Pushing "1.05" to the FPU stack...
mov dword ptr [result],0x3f866666 #IEEE754 hex of 1.05
fld dword ptr [result]
#Pushing "(* (+ (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) 1.05)" to the FPU stack...
fmulp
#Pushing "(+ (* (* (- (- (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) (ln 2)) 0.9163) (abs polinom_pod_apsolutnom)) (* (+ (ln (ln (- gornja_granica donja_granica))) (ln (- gornja_granica donja_granica))) 1.05))" to the FPU stack...
fxch
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [Eulerov_broj_na_koju_potenciju],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#koliko_usporedbi_ocekujemo_od_QuickSorta := exp(Eulerov_broj_na_koju_potenciju)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "Eulerov_broj_na_koju_potenciju" to the FPU stack...
fld dword ptr [Eulerov_broj_na_koju_potenciju]
#Pushing "(exp Eulerov_broj_na_koju_potenciju)" to the FPU stack...
fldl2e
fmulp
fld1
fscale
fxch
fld1
fxch
fprem
f2xm1
faddp
fmulp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [koliko_usporedbi_ocekujemo_od_QuickSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#koliko_usporedbi_ocekujemo_od_MergeSorta := 2 * (gornja_granica - donja_granica) * ln(gornja_granica - donja_granica) / ln(2)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(* (- gornja_granica donja_granica) 2)" to the FPU stack...
fxch
fmulp
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(- gornja_granica donja_granica)" to the FPU stack...
fsubp
#Pushing "(ln (- gornja_granica donja_granica))" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(* (* (- gornja_granica donja_granica) 2) (ln (- gornja_granica donja_granica)))" to the FPU stack...
fmulp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(ln 2)" to the FPU stack...
fld1
fxch
fyl2x
fldl2e
fdivp
#Pushing "(/ (* (* (- gornja_granica donja_granica) 2) (ln (- gornja_granica donja_granica))) (ln 2))" to the FPU stack...
fdivp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [koliko_usporedbi_ocekujemo_od_MergeSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If razvrstanost=1 ;Ako je niz vec poredan.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(= razvrstanost 1)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel36961
fld1
jmp endOfTheEqualityOperatorLabel702693
operandsOfTheEqualityOperatorAreNotEqualLabel36961:
fldz
endOfTheEqualityOperatorLabel702693:
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel381656
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_vec_poredanih_podniza := broj_vec_poredanih_podniza + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_vec_poredanih_podniza" to the FPU stack...
fld dword ptr [broj_vec_poredanih_podniza]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ broj_vec_poredanih_podniza 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [broj_vec_poredanih_podniza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#ElseIf razvrstanost = -1 ;Ako je niz obrnuto poredan...
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: ElseIf-statement.
#If the expression in the If-statement evaluates to 1...
jmp EndIfLabel922565
#If it evaluates to 0...
ElseLabel381656:
#Evaluating the expression after the ElseIf keyword...
#Pushing "0" to the FPU stack...
mov dword ptr [result],0x0 #IEEE754 hex of 0
fld dword ptr [result]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- 0 1)" to the FPU stack...
fsubp
#Pushing "razvrstanost" to the FPU stack...
fld dword ptr [razvrstanost]
#Pushing "(= (- 0 1) razvrstanost)" to the FPU stack...
fxch
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel157934
fld1
jmp endOfTheEqualityOperatorLabel764986
operandsOfTheEqualityOperatorAreNotEqualLabel157934:
fldz
endOfTheEqualityOperatorLabel764986:
#Comparing that expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it was 0...
jz ElseLabel949946
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_obrnuto_poredanih_podniza := broj_obrnuto_poredanih_podniza + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_obrnuto_poredanih_podniza" to the FPU stack...
fld dword ptr [broj_obrnuto_poredanih_podniza]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ broj_obrnuto_poredanih_podniza 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [broj_obrnuto_poredanih_podniza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i                              :=                      donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j                              :=                 gornja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel301091:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel726552
fld1
jmp endOfTheLessThanComparisonLabel881422
secondOperandOfTheComparisonIsSmallerOrEqualLabel726552:
fldz
endOfTheLessThanComparisonLabel881422:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel566036
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i] := originalni_niz[j]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "(originalni_niz j)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [pomocni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j              :=             j - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- j 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i              :=             i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel301091
EndWhileLabel566036:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i < gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel382091:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel385853
fld1
jmp endOfTheLessThanComparisonLabel72309
secondOperandOfTheComparisonIsSmallerOrEqualLabel385853:
fldz
endOfTheLessThanComparisonLabel72309:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel512516
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i] := pomocni_niz[i]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(pomocni_niz i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [pomocni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel382091
EndWhileLabel512516:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#ElseIf koliko_usporedbi_ocekujemo_od_MergeSorta < koliko_usporedbi_ocekujemo_od_QuickSorta | vrh_stoga > pow(2, 10) - pow(2, 6) ;MergeSort algoritam (priblizno poredani podnizovi, za koje je MergeSort efikasniji od QuickSorta, a moj ga program takoder koristi kada ima jos malo mjesta na sistemskom stogu, pa QuickSort nije opcija)...
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: ElseIf-statement.
#If the expression in the If-statement evaluates to 1...
jmp EndIfLabel922565
#If it evaluates to 0...
ElseLabel949946:
#Evaluating the expression after the ElseIf keyword...
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "10" to the FPU stack...
mov dword ptr [result],0x41200000 #IEEE754 hex of 10
fld dword ptr [result]
#Pushing "(pow 2 10)" to the FPU stack...
fxch
fld1
fxch
fyl2x
fldl2e
fdivp
fmulp
fldl2e
fmulp
fld1
fscale
fxch
fld1
fxch
fprem
f2xm1
faddp
fmulp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "6" to the FPU stack...
mov dword ptr [result],0x40c00000 #IEEE754 hex of 6
fld dword ptr [result]
#Pushing "(pow 2 6)" to the FPU stack...
fxch
fld1
fxch
fyl2x
fldl2e
fdivp
fmulp
fldl2e
fmulp
fld1
fscale
fxch
fld1
fxch
fprem
f2xm1
faddp
fmulp
#Pushing "(- (pow 2 10) (pow 2 6))" to the FPU stack...
fsubp
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(> (- (pow 2 10) (pow 2 6)) vrh_stoga)" to the FPU stack...
fxch
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jnb secondOperandOfTheComparisonIsGreaterOrEqualLabel359644
fld1
jmp endOfTheGreaterThanComparisonLabel1243
secondOperandOfTheComparisonIsGreaterOrEqualLabel359644:
fldz
endOfTheGreaterThanComparisonLabel1243:
#Pushing "koliko_usporedbi_ocekujemo_od_MergeSorta" to the FPU stack...
fld dword ptr [koliko_usporedbi_ocekujemo_od_MergeSorta]
#Pushing "koliko_usporedbi_ocekujemo_od_QuickSorta" to the FPU stack...
fld dword ptr [koliko_usporedbi_ocekujemo_od_QuickSorta]
#Pushing "(< koliko_usporedbi_ocekujemo_od_MergeSorta koliko_usporedbi_ocekujemo_od_QuickSorta)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel826603
fld1
jmp endOfTheLessThanComparisonLabel576875
secondOperandOfTheComparisonIsSmallerOrEqualLabel826603:
fldz
endOfTheLessThanComparisonLabel576875:
#Pushing "(| (> (- (pow 2 10) (pow 2 6)) vrh_stoga) (< koliko_usporedbi_ocekujemo_od_MergeSorta koliko_usporedbi_ocekujemo_od_QuickSorta))" to the FPU stack...
fxch
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
or dword ptr [result],eax
fild dword ptr [result]
#Comparing that expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it was 0...
jz ElseLabel421326
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_pokretanja_MergeSorta :=       broj_pokretanja_MergeSorta + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_pokretanja_MergeSorta" to the FPU stack...
fld dword ptr [broj_pokretanja_MergeSorta]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ broj_pokretanja_MergeSorta 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [broj_pokretanja_MergeSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza               := (gornja_granica + donja_granica) / 2
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "(+ gornja_granica donja_granica)" to the FPU stack...
faddp
#Pushing "2" to the FPU stack...
mov dword ptr [result],0x40000000 #IEEE754 hex of 2
fld dword ptr [result]
#Pushing "(/ (+ gornja_granica donja_granica) 2)" to the FPU stack...
fdivp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza               :=   sredina_niza - mod(sredina_niza,1)
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(mod sredina_niza 1)" to the FPU stack...
fxch
fprem
fxch
fstp dword ptr [result]
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Pushing "(- (mod sredina_niza 1) sredina_niza)" to the FPU stack...
fxch
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga                  :=                        vrh_stoga + 1 ;Zauzmi mjesta na stogu za rekurziju. Ne koristimo sistemski stog, kao sto koristi C++, nego koristimo vise globalnih polja kao stogove. Da koristimo sistemski stog, morali bismo znati pokrecemo li se na 32-bitnom Linuxu ili 64-bitnom Linuxu, jer oni nisu kompatibilni u tom pogledu.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ vrh_stoga 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_donjim_granicama[vrh_stoga]  := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_s_donjim_granicama+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_gornjim_granicama[vrh_stoga] := gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_s_gornjim_granicama+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_sa_sredinama_niza[vrh_stoga]   := sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_sa_sredinama_niza+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica                      := sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#donja_granica  :=  stog_s_donjim_granicama[vrh_stoga] ;Sad je rekurzija gotovo sigurno izmijenila sve globalne varijable koje nam trebaju ("donja_granica", "gornja_granica" i "sredina_niza"), ali zato imamo njihove stare vrijednosti na stogovima.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_donjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica := stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_gornjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza   :=   stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_sa_sredinama_niza+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#donja_granica  :=                        sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#donja_granica  :=  stog_s_donjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_donjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica := stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_gornjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#sredina_niza   :=   stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_sa_sredinama_niza+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [sredina_niza],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;Spajanje nizova originalni_niz[donja_granica..sredina_niza] i originalni_niz[sredina_niza..gornja_granica] u jedan niz...
#The entire line is a comment, moving on...
#i                      := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_prvom_nizu  := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_prvom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_drugom_nizu := sredina_niza
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_drugom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel861170:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel908073
fld1
jmp endOfTheLessThanComparisonLabel365177
secondOperandOfTheComparisonIsSmallerOrEqualLabel908073:
fldz
endOfTheLessThanComparisonLabel365177:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel48970
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If (gdje_smo_u_prvom_nizu=sredina_niza | originalni_niz[gdje_smo_u_drugom_nizu]<originalni_niz[gdje_smo_u_prvom_nizu]) & gdje_smo_u_drugom_nizu<gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "(originalni_niz gdje_smo_u_drugom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "(originalni_niz gdje_smo_u_prvom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "(< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu))" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel277631
fld1
jmp endOfTheLessThanComparisonLabel181682
secondOperandOfTheComparisonIsSmallerOrEqualLabel277631:
fldz
endOfTheLessThanComparisonLabel181682:
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "sredina_niza" to the FPU stack...
fld dword ptr [sredina_niza]
#Pushing "(= gdje_smo_u_prvom_nizu sredina_niza)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jne operandsOfTheEqualityOperatorAreNotEqualLabel109783
fld1
jmp endOfTheEqualityOperatorLabel208626
operandsOfTheEqualityOperatorAreNotEqualLabel109783:
fldz
endOfTheEqualityOperatorLabel208626:
#Pushing "(| (< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu)) (= gdje_smo_u_prvom_nizu sredina_niza))" to the FPU stack...
fxch
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
or dword ptr [result],eax
fild dword ptr [result]
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< gdje_smo_u_drugom_nizu gornja_granica)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel459719
fld1
jmp endOfTheLessThanComparisonLabel562086
secondOperandOfTheComparisonIsSmallerOrEqualLabel459719:
fldz
endOfTheLessThanComparisonLabel562086:
#Pushing "(& (| (< (originalni_niz gdje_smo_u_drugom_nizu) (originalni_niz gdje_smo_u_prvom_nizu)) (= gdje_smo_u_prvom_nizu sredina_niza)) (< gdje_smo_u_drugom_nizu gornja_granica))" to the FPU stack...
fistp dword ptr [result]
mov eax,dword ptr [result]
fistp dword ptr [result]
and dword ptr [result],eax
fild dword ptr [result]
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel727610
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i]         := originalni_niz[gdje_smo_u_drugom_nizu]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "(originalni_niz gdje_smo_u_drugom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [pomocni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_drugom_nizu :=             gdje_smo_u_drugom_nizu + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_drugom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_drugom_nizu]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ gdje_smo_u_drugom_nizu 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_drugom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#Else
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: Else-statement.
jmp EndIfLabel82081
ElseLabel727610:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocni_niz[i]        := originalni_niz[gdje_smo_u_prvom_nizu]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "(originalni_niz gdje_smo_u_prvom_nizu)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [pomocni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_smo_u_prvom_nizu := gdje_smo_u_prvom_nizu + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_smo_u_prvom_nizu" to the FPU stack...
fld dword ptr [gdje_smo_u_prvom_nizu]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ gdje_smo_u_prvom_nizu 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_smo_u_prvom_nizu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
EndIfLabel82081:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel861170
EndWhileLabel48970:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i := donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While i < gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel750079:
#Evaluating the expression after the "While" keyword
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "(< i gornja_granica)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel292239
fld1
jmp endOfTheLessThanComparisonLabel602091
secondOperandOfTheComparisonIsSmallerOrEqualLabel292239:
fldz
endOfTheLessThanComparisonLabel602091:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel143439
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i] := pomocni_niz[i]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(pomocni_niz i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [pomocni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i                 :=          i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel750079
EndWhileLabel143439:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga:=vrh_stoga-1 ;Oslobodi mjesto na stogovima.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- vrh_stoga 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#Else ;QuickSort algoritam (nasumicno ispremjestani podnizovi)...
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: Else-statement.
jmp EndIfLabel922565
ElseLabel421326:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#broj_pokretanja_QuickSorta := broj_pokretanja_QuickSorta + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "broj_pokretanja_QuickSorta" to the FPU stack...
fld dword ptr [broj_pokretanja_QuickSorta]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ broj_pokretanja_QuickSorta 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [broj_pokretanja_QuickSorta],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#;Daljnji kod je priblizno prepisan s https://www.geeksforgeeks.org/quick-sort/
#The entire line is a comment, moving on...
#pivot := originalni_niz[gornja_granica - 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "(originalni_niz (- gornja_granica 1))" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [pivot],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i     :=                  donja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- donja_granica 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j     :=                      donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#While j < gornja_granica - 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: beginning of the while-loop
#Marking where the evaluation of the expression begins (because it needs to be repeated once we come to the end of the loop).
WhileLabel92111:
#Evaluating the expression after the "While" keyword
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "(< (- gornja_granica 1) j)" to the FPU stack...
fxch
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel922841
fld1
jmp endOfTheLessThanComparisonLabel421251
secondOperandOfTheComparisonIsSmallerOrEqualLabel922841:
fldz
endOfTheLessThanComparisonLabel421251:
#Comparing the expression to 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether it is 0...
je EndWhileLabel491844
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#If originalni_niz[j] < pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: if-statement.
#Calculating the expression...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "(originalni_niz j)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Pushing "pivot" to the FPU stack...
fld dword ptr [pivot]
#Pushing "(< (originalni_niz j) pivot)" to the FPU stack...
fcomp
push ax
fstsw ax
mov al,ah
lahf
and ax,0xba45 #https://www.vogons.org/viewtopic.php?p=1130827#p1130827
or ah,al
sahf
pop ax
fstp dword ptr [result]
jna secondOperandOfTheComparisonIsSmallerOrEqualLabel523859
fld1
jmp endOfTheLessThanComparisonLabel109945
secondOperandOfTheComparisonIsSmallerOrEqualLabel523859:
fldz
endOfTheLessThanComparisonLabel109945:
#Comparing the just-calculated expression with 0...
fistp dword ptr [result]
mov eax, dword ptr [result]
test eax,eax
#Branching based on whether the expression is 0...
jz ElseLabel797851
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#i                             :=                         i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [i],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocna_varijabla_za_zamijenu :=             originalni_niz[i]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "(originalni_niz i)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [pomocna_varijabla_za_zamijenu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i]             :=            originalni_niz [j]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "(originalni_niz j)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[j]             := pomocna_varijabla_za_zamijenu
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "pomocna_varijabla_za_zamijenu" to the FPU stack...
fld dword ptr [pomocna_varijabla_za_zamijenu]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
ElseLabel797851:
EndIfLabel283320:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#j := j + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "j" to the FPU stack...
fld dword ptr [j]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ j 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [j],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#EndWhile
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive: end of the while-loop.
jmp WhileLabel92111
EndWhileLabel491844:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#pomocna_varijabla_za_zamijenu       :=              originalni_niz[i + 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Pushing "(originalni_niz (+ i 1))" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [pomocna_varijabla_za_zamijenu],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[i + 1]               := originalni_niz[gornja_granica - 1]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Pushing "(originalni_niz (- gornja_granica 1))" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [originalni_niz+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#originalni_niz[gornja_granica - 1]  :=      pomocna_varijabla_za_zamijenu
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "pomocna_varijabla_za_zamijenu" to the FPU stack...
fld dword ptr [pomocna_varijabla_za_zamijenu]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- gornja_granica 1)" to the FPU stack...
fsubp
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [originalni_niz+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_je_pivot                       :=                              i + 1
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "i" to the FPU stack...
fld dword ptr [i]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ i 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_je_pivot],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#vrh_stoga                           :=                      vrh_stoga + 1 ;Zauzmi mjesta na stogu za rekurziju (ne koristimo sistemski stog, kao sto koristi C++, nego koristimo vise globalnih polja kao stogove).
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(+ vrh_stoga 1)" to the FPU stack...
faddp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_donjim_granicama[vrh_stoga]  :=                      donja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "donja_granica" to the FPU stack...
fld dword ptr [donja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_s_donjim_granicama+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_s_gornjim_granicama[vrh_stoga] :=                     gornja_granica
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gornja_granica" to the FPU stack...
fld dword ptr [gornja_granica]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_s_gornjim_granicama+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#stog_sa_sredinama_niza[vrh_stoga]   :=                      gdje_je_pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_je_pivot" to the FPU stack...
fld dword ptr [gdje_je_pivot]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Calculating the l-value...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Moving the pointer from "st0" to "ebx".
fistp dword ptr [result]
mov ebx, dword ptr [result]
#Storing the r-value (now in "edx") where "ebx" points to.
mov dword ptr [stog_sa_sredinama_niza+4*ebx],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica                      :=                      gdje_je_pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_je_pivot" to the FPU stack...
fld dword ptr [gdje_je_pivot]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#donja_granica  :=  stog_s_donjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_donjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_donjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gornja_granica := stog_s_gornjim_granicama[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_s_gornjim_granicama vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_s_gornjim_granicama+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gornja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#gdje_je_pivot  :=   stog_sa_sredinama_niza[vrh_stoga]
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "(stog_sa_sredinama_niza vrh_stoga)" to the FPU stack...
fistp dword ptr [result]
mov ebx,dword ptr [result]
fld dword ptr [stog_sa_sredinama_niza+4*ebx]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [gdje_je_pivot],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#donja_granica  :=                       gdje_je_pivot
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "gdje_je_pivot" to the FPU stack...
fld dword ptr [gdje_je_pivot]
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [donja_granica],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
call hybrid_sort
#AsmEnd
#Inline assembly ended.
#vrh_stoga := vrh_stoga - 1 ;Oslobodi mjesto na stogovima.
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: assignment.
#Calculating the rvalue...
#Pushing "vrh_stoga" to the FPU stack...
fld dword ptr [vrh_stoga]
#Pushing "1" to the FPU stack...
mov dword ptr [result],0x3f800000 #IEEE754 hex of 1
fld dword ptr [result]
#Pushing "(- vrh_stoga 1)" to the FPU stack...
fsubp
#Storing the top of the FPU stack into "edx".
fstp dword ptr [result]
mov edx, dword ptr [result]
#Storing the r-value (now in "edx") into the variable.
mov dword ptr [vrh_stoga],edx
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart
#Inline assembly begins.
ret
#AsmEnd
#Inline assembly ended.
#EndIf
#We don't know which mode the assembler is in right now, so let's switch it to the intel_syntax mode.
.intel_syntax noprefix
#Initializing the FPU stack...
finit
#Type of the directive is: EndIf-statement.
EndIfLabel922565:
#We don't know what comes next, whichever program will control the assembler next will likely expect it to be in the att_syntax mode.
.att_syntax
#AsmStart ;Ovdje tok programa ne smije doci. Ako dode, pozovi debugger.
#Inline assembly begins.
call abort
#AsmEnd
#Inline assembly ended.
