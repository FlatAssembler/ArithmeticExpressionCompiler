/*
        This is an advanced example of how to embed Assembly
        produced by ArithmeticExpressionCompiler
        into C programs that can be compiled with GCC and CLANG.
	 
        For an introduction into the topic, see:
        https://flatassembler.github.io/quadratic.c
 */

int printf(const char*, ...);
/* Because GCC 4.8.5, for some reason that escapes me,
   crashes if you try to include "stdio.h" on 64-bit Oracle Linux 7
   while setting it to be in 32-bit mode and telling it to compile this program (Seriously!).*/

float result, i, delta, sinArray[314], cosArray[314], pi;

int main() {
    printf("rad\tdeg\tsin\tcos\ttan\n");
#ifndef _WIN32
    /*
       So, this program uses one of the simplest and yet the fastest ways of 
       approximating the values of trigonometric functions in radians.
       It works by sin(0)=0, cos(0)=1, the derivative of sine in radians being equal to the cosine,
       and the derivative of cosine being equal to the negative sine.
       So, all you need to do to approximate the sine and cosine of a given 
       angle in radians is to pick some small delta,
       and then (angle/delta) times add delta*cosine to the temporary value of sine,
       and at the same time keep subtracting delta*sine from the temporary value of cosine.  
     */
    asm(".intel_syntax\n"
                "#Generated by Arithmetic Expression Compiler (http://flatassembler.000webhostapp.com/compiler.html) run in Duktape.\n"
                "#delta:=1/100\n"
                "finit\n"
                "mov dword ptr [result],0x3F800000 #1\n"
                "fld dword ptr [result]\n"
                "mov dword ptr [result],0x42C80000 #100\n"
                "fld dword ptr [result]\n"
                "fdivp #st1,st0\n"
                "fstp dword ptr [result]\n"
                "push dword ptr [result]\n"
                "pop dword ptr [delta]\n"
                "#i:=0\n"
                "finit\n"
                "mov dword ptr [result],0x0 #0\n"
                "fld dword ptr [result]\n"
                "fstp dword ptr [result]\n"
                "push dword ptr [result]\n"
                "pop dword ptr [i]\n"
                "#sinArray[i]:=i\n"
                "finit\n"
                "fld dword ptr [i]\n"
                "fstp dword ptr [result]\n"
                "push dword ptr [result]\n"
                "fld dword ptr [i]\n"
                "fistp dword ptr [result]\n"
                "mov ebx, dword ptr [result]\n"
                /* Older versions of GAS apparently require you to explicitly denote that "[result]" is a 32-bit pointer,
                   even when you are explicitly moving what it points to... to a 32-bit register (in this case "ebx").*/
                "pop dword ptr [sinArray+4*ebx]\n"
                "#cosArray[i]:=1\n"
                "finit\n"
                "mov dword ptr [result],0x3F800000 #1\n"
                "fld dword ptr [result]\n"
                "fstp dword ptr [result]\n"
                "push dword ptr [result]\n"
                "fld dword ptr [i]\n"
                "fistp dword ptr [result]\n"
                "mov ebx, dword ptr[result]\n"
                "pop dword ptr [cosArray+4*ebx]\n"
                "#While i<314\n"
                "finit\n"
                "l628623:\n"
                "fld dword ptr [i]\n"
                "mov dword ptr [result],0x439D0000 #314\n"
                "fld dword ptr [result]\n"
                "#fcomip #st1\n" //Older versions of GAS, such as the GAS 2.27, one shipped with Oracle Linux 7, apparently don't support "fcomip".
                "fcomi\nfstp dword ptr [result]\n" //Nevertheless, there is an obvious and simple work-around.
                "mov dword ptr [sinArray],0\n" //I don't know why this is necessary, apparently "fcomip" isn't the same as "fcomi"+"fstp", however, this appears to fix the issue.
                "fstp dword ptr [result]\n"
                "jna l280382\n"
                "fld1\n"
                "jmp l837287\n"
                "l280382:\n"
                "fldz\n"
                "l837287:\n"
                "fistp dword ptr [result]\n"
                "mov eax,dword ptr [result]\n"
                "test eax,eax\n"
                "je l467414\n"
                "#i:=i+1\n"
                "finit\n"
                "fld dword ptr [i]\n"
                "mov dword ptr [result],0x3F800000 #1\n"
                "fld dword ptr [result]\n"
                "faddp #st1,st0\n"
                "fstp dword ptr [result]\n"
                "push dword ptr [result]\n"
                "pop dword ptr [i]\n"
                "#sinArray[i]:=sinArray(i-1)+delta*cosArray(i-1)\n"
                "finit\n"
                "fld dword ptr [i]\n"
                "mov dword ptr [result],0x3F800000 #1\n"
                "fld dword ptr [result]\n"
                "fsubp #st1,st0\n"
                "fistp dword ptr [result]\n"
                "mov ebx,dword ptr [result]\n"
                "fld dword ptr [cosArray+4*ebx] #In case the program is supposed to be 16-bit, simply replace 'ebx' with 'bx'. In case it's 64-bit, replace the 'mov' in the last directive with 'movsx' and 'ebx' with 'rbx' in both this and the last directive.\n"
                /*GAS, unlike FlatAssembler, takes care of the differences between 32-bit and 64-bit here,
                 you don't need to do anything in this case.*/
                "fld dword ptr [delta]\n"
                "fxch\n"
                "fmulp #st1,st0\n"
                "fld dword ptr [i]\n"
                "mov dword ptr [result],0x3F800000 #1\n"
                "fld dword ptr [result]\n"
                "fsubp #st1,st0\n"
                "fistp dword ptr [result]\n"
                "mov ebx, dword ptr [result]\n"
                "fld dword ptr [sinArray+4*ebx] #In case the program is supposed to be 16-bit, simply replace 'ebx' with 'bx'. In case it's 64-bit, replace the 'mov' in the last directive with 'movsx' and 'ebx' with 'rbx' in both this and the last directive.\n"
                "fxch\n"
                "faddp #st1,st0\n"
                "fstp dword ptr [result]\n"
                "push dword ptr [result]\n"
                "fld dword ptr [i]\n"
                "fistp dword ptr [result]\n"
                "mov ebx, dword ptr [result]\n"
                "pop dword ptr [sinArray+4*ebx]\n"
                "#cosArray[i]:=cosArray(i-1)-delta*sinArray(i-1)\n"
                "finit\n"
                "fld dword ptr [i]\n"
                "mov dword ptr [result],0x3F800000 #1\n"
                "fld dword ptr [result]\n"
                "fsubp #st1,st0\n"
                "fistp dword ptr [result]\n"
                "mov ebx, dword ptr [result]\n"
                "fld dword ptr [sinArray+4*ebx] #In case the program is supposed to be 16-bit, simply replace 'ebx' with 'bx'. In case it's 64-bit, replace the 'mov' in the last directive with 'movsx' and 'ebx' with 'rbx' in both this and the last directive.\n"
                "fld dword ptr [delta]\n"
                "fxch\n"
                "fmulp #st1,st0\n"
                "fld dword ptr [i]\n"
                "mov dword ptr [result],0x3F800000 #1\n"
                "fld dword ptr [result]\n"
                "fsubp #st1,st0\n"
                "fistp dword ptr [result]\n"
                "mov ebx,dword ptr [result]\n"
                "fld dword ptr [cosArray+4*ebx] #In case the program is supposed to be 16-bit, simply replace 'ebx' with 'bx'. In case it's 64-bit, replace the 'mov' in the last directive with 'movsx' and 'ebx' with 'rbx' in both this and the last directive.\n"
                "fxch\n"
                "fsubp #st1,st0\n"
                "fstp dword ptr [result]\n"
                "push dword ptr [result]\n"
                "fld dword ptr [i]\n"
                "fistp dword ptr [result]\n"
                "mov ebx,dword ptr [result]\n"
                "pop dword ptr [cosArray+4*ebx]\n"
                "#EndWhile\n"
                "finit\n"
                "jmp l628623\n"
                "l467414:\n"
                ".att_syntax\n");
#else //So, what follows is a code that can be compiled with a fairly recent version of GCC, TDM-GCC 5.1.0, running on Windows.
    asm(".intel_syntax\n"
                "#Generated by Arithmetic Expression Compiler (http://flatassembler.000webhostapp.com/compiler.html) run in Duktape.\n"
                "#delta:=1/100\n"
                "finit\n"
                "mov dword ptr [_result],0x3F800000 #1\n"
                "fld dword ptr [_result]\n"
                "mov dword ptr [_result],0x42C80000 #100\n"
                "fld dword ptr [_result]\n"
                "fdivp #st1,st0\n"
                "fstp dword ptr [_result]\n"
                "push dword ptr [_result]\n"
                "pop dword ptr [_delta]\n"
                "#i:=0\n"
                "finit\n"
                "mov dword ptr [_result],0x0 #0\n"
                "fld dword ptr [_result]\n"
                "fstp dword ptr [_result]\n"
                "push dword ptr [_result]\n"
                "pop dword ptr [_i]\n"
                "#sinArray[i]:=i\n"
                "finit\n"
                "fld dword ptr [_i]\n"
                "fstp dword ptr [_result]\n"
                "push dword ptr [_result]\n"
                "fld dword ptr [_i]\n"
                "fistp dword ptr [_result]\n"
                "mov ebx,[_result]\n"
                "pop dword ptr [_sinArray+4*ebx]\n"
                "#cosArray[i]:=1\n"
                "finit\n"
                "mov dword ptr [_result],0x3F800000 #1\n"
                "fld dword ptr [_result]\n"
                "fstp dword ptr [_result]\n"
                "push dword ptr [_result]\n"
                "fld dword ptr [_i]\n"
                "fistp dword ptr [_result]\n"
                "mov ebx,[_result]\n"
                "pop dword ptr [_cosArray+4*ebx]\n"
                "#While i<314\n"
                "finit\n"
                "l628623:\n"
                "fld dword ptr [_i]\n"
                "mov dword ptr [_result],0x439D0000 #314\n"
                "fld dword ptr [_result]\n"
                "fcomip #st1\n"
                "fstp dword ptr [_result]\n"
                "jna l280382\n"
                "fld1\n"
                "jmp l837287\n"
                "l280382:\n"
                "fldz\n"
                "l837287:\n"
                "fistp dword ptr [_result]\n"
                "mov eax,[_result]\n"
                "test eax,eax\n"
                "je l467414\n"
                "#i:=i+1\n"
                "finit\n"
                "fld dword ptr [_i]\n"
                "mov dword ptr [_result],0x3F800000 #1\n"
                "fld dword ptr [_result]\n"
                "faddp #st1,st0\n"
                "fstp dword ptr [_result]\n"
                "push dword ptr [_result]\n"
                "pop dword ptr [_i]\n"
                "#sinArray[i]:=sinArray(i-1)+delta*cosArray(i-1)\n"
                "finit\n"
                "fld dword ptr [_i]\n"
                "mov dword ptr [_result],0x3F800000 #1\n"
                "fld dword ptr [_result]\n"
                "fsubp #st1,st0\n"
                "fistp dword ptr [_result]\n"
                "mov ebx,[_result]\n"
                "fld dword ptr [_cosArray+4*ebx] #In case the program is supposed to be 16-bit, simply replace 'ebx' with 'bx'. In case it's 64-bit, replace the 'mov' in the last directive with 'movsx' and 'ebx' with 'rbx' in both this and the last directive.\n"
                "fld dword ptr [_delta]\n"
                "fxch\n"
                "fmulp #st1,st0\n"
                "fld dword ptr [_i]\n"
                "mov dword ptr [_result],0x3F800000 #1\n"
                "fld dword ptr [_result]\n"
                "fsubp #st1,st0\n"
                "fistp dword ptr [_result]\n"
                "mov ebx,[_result]\n"
                "fld dword ptr [_sinArray+4*ebx] #In case the program is supposed to be 16-bit, simply replace 'ebx' with 'bx'. In case it's 64-bit, replace the 'mov' in the last directive with 'movsx' and 'ebx' with 'rbx' in both this and the last directive.\n"
                "fxch\n"
                "faddp #st1,st0\n"
                "fstp dword ptr [_result]\n"
                "push dword ptr [_result]\n"
                "fld dword ptr [_i]\n"
                "fistp dword ptr [_result]\n"
                "mov ebx,[_result]\n"
                "pop dword ptr [_sinArray+4*ebx]\n"
                "#cosArray[i]:=cosArray(i-1)-delta*sinArray(i-1)\n"
                "finit\n"
                "fld dword ptr [_i]\n"
                "mov dword ptr [_result],0x3F800000 #1\n"
                "fld dword ptr [_result]\n"
                "fsubp #st1,st0\n"
                "fistp dword ptr [_result]\n"
                "mov ebx,[_result]\n"
                "fld dword ptr [_sinArray+4*ebx] #In case the program is supposed to be 16-bit, simply replace 'ebx' with 'bx'. In case it's 64-bit, replace the 'mov' in the last directive with 'movsx' and 'ebx' with 'rbx' in both this and the last directive.\n"
                "fld dword ptr [_delta]\n"
                "fxch\n"
                "fmulp #st1,st0\n"
                "fld dword ptr [_i]\n"
                "mov dword ptr [_result],0x3F800000 #1\n"
                "fld dword ptr [_result]\n"
                "fsubp #st1,st0\n"
                "fistp dword ptr [_result]\n"
                "mov ebx,[_result]\n"
                "fld dword ptr [_cosArray+4*ebx] #In case the program is supposed to be 16-bit, simply replace 'ebx' with 'bx'. In case it's 64-bit, replace the 'mov' in the last directive with 'movsx' and 'ebx' with 'rbx' in both this and the last directive.\n"
                "fxch\n"
                "fsubp #st1,st0\n"
                "fstp dword ptr [_result]\n"
                "push dword ptr [_result]\n"
                "fld dword ptr [_i]\n"
                "fistp dword ptr [_result]\n"
                "mov ebx,[_result]\n"
                "pop dword ptr [_cosArray+4*ebx]\n"
                "#EndWhile\n"
                "finit\n"
                "jmp l628623\n"
                "l467414:\n"
                ".att_syntax\n");
#endif
    asm(".intel_syntax\n"
                "fldpi\n"
#ifdef _WIN32
                "fstp dword ptr [_pi]\n"
#else
                "fstp dword ptr [pi]\n"
#endif
                ".att_syntax"
                ); /*I am not sure what would be a more portable way of getting
                     the value of pi between different C compilers,
                     especially if you have access to x86 assembly.*/
    int i;
    for (i = 0; i < 314; i++) {
        printf("%.2f\t%.2f\t%.2f\t%.2f\t%.2f\n",
                (float) i / 100,
                (float) i / 100 * (180 / pi),
                sinArray[i],
                cosArray[i],
                sinArray[i] / cosArray[i]);
    }
}
